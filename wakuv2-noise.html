<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Noise handshakes as key-exchange mechanism for Waku</title><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="description" content="We provide an overview of the Noise Protocol Framework as a tool to design efficient and secure key-exchange mechanisms in Waku2."/><link rel="shortcut icon" href="/assets/logo/vac/favicon.ico"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:creator" content="vacp2p"/><meta name="twitter:site" content="@vacp2p"/><meta name="twitter:title" content="Noise handshakes as key-exchange mechanism for Waku"/><meta name="twitter:description" content="We provide an overview of the Noise Protocol Framework as a tool to design efficient and secure key-exchange mechanisms in Waku2."/><meta name="twitter:image" content="https://staging.vac.dev/compiled-assets/img/noise/NM.png"/><meta property="og:url" content="https://staging.vac.dev//wakuv2-noise"/><meta property="og:image" content="https://staging.vac.dev/compiled-assets/img/noise/NM.png"/><meta property="og:site_name" content="Noise handshakes as key-exchange mechanism for Waku"/><meta property="og:title" content="Noise handshakes as key-exchange mechanism for Waku"/><meta property="og:description" content="We provide an overview of the Noise Protocol Framework as a tool to design efficient and secure key-exchange mechanisms in Waku2."/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/e068b41030ceede6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e068b41030ceede6.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cdd95df0746869ac.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cdd95df0746869ac.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script defer="" src="/_next/static/chunks/440.30d6564577c1ada0.js"></script><script src="/_next/static/chunks/webpack-a14325fd952bf0eb.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-ada0258e433ba222.js" defer=""></script><script src="/_next/static/chunks/pages/_app-91f05ffa21c9a6ec.js" defer=""></script><script src="/_next/static/chunks/eb1842f2-90eb16656390ba2a.js" defer=""></script><script src="/_next/static/chunks/399-b4b9981c243e7c94.js" defer=""></script><script src="/_next/static/chunks/108-374a17adb21bb412.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...path%5D%5D-9c3054039bf889f4.js" defer=""></script><script src="/_next/static/-5vfLOflCSkQPJRugO7ZO/_buildManifest.js" defer=""></script><script src="/_next/static/-5vfLOflCSkQPJRugO7ZO/_ssgManifest.js" defer=""></script><script src="/_next/static/-5vfLOflCSkQPJRugO7ZO/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><svg width="0" height="0" xmlns="http://www.w3.org/2000/svg" style="display:none"><defs><filter id="colored"><feColorMatrix type="matrix" values="1.00 0 0 0 0 0 1.00 0 0 0 0 0 1.00 0 0 0 0 0 1 0"></feColorMatrix></filter></defs></svg><style nonce="logos">
      #nprogress {
        pointer-events: none;
      }
      #nprogress .bar {
        background: #000000;
        position: fixed;
        z-index: 9999;
        top: 0;
        left: 0;
        width: 100%;
        height: 3px;
      }
      #nprogress .peg {
        display: block;
        position: absolute;
        right: 0px;
        width: 100px;
        height: 100%;
        box-shadow: 0 0 10px #000000, 0 0 5px #000000;
        opacity: 1;
        -webkit-transform: rotate(3deg) translate(0px, -4px);
        -ms-transform: rotate(3deg) translate(0px, -4px);
        transform: rotate(3deg) translate(0px, -4px);
      }
      #nprogress .spinner {
        display: block;
        position: fixed;
        z-index: 1031;
        top: 15px;
        right: 15px;
      }
      #nprogress .spinner-icon {
        width: 18px;
        height: 18px;
        box-sizing: border-box;
        border: solid 2px transparent;
        border-top-color: #000000;
        border-left-color: #000000;
        border-radius: 50%;
        -webkit-animation: nprogresss-spinner 400ms linear infinite;
        animation: nprogress-spinner 400ms linear infinite;
      }
      .nprogress-custom-parent {
        overflow: hidden;
        position: relative;
      }
      .nprogress-custom-parent #nprogress .spinner,
      .nprogress-custom-parent #nprogress .bar {
        position: absolute;
      }
      @-webkit-keyframes nprogress-spinner {
        0% {
          -webkit-transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
        }
      }
      @keyframes nprogress-spinner {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style><div class="Style_container__qv2Yk Styles_common_container__u_XHj template-container"><header class="Styles_container__5FUI_ Style_header__IYvBP undefined"><div class="Styles_innerWrapper__ZInvp"><div class="logo-holder button vac" style="display:inline-block"><svg width="45" height="43" viewBox="0 0 35 43" fill="none" xmlns="http://www.w3.org/2000/svg" class="vac-logo"><g clip-path="url(#clip0_917_3082)"><path d="M24.9034 14.8217C24.6824 11.2666 23.5308 7.8298 21.5623 4.84994C22.543 4.19721 23.7374 3.93844 24.9034 4.12603C25.492 4.23064 26.0472 4.4722 26.5233 4.83086C26.9994 5.18951 27.3828 5.65504 27.6421 6.18916C28.0141 7.1512 28.1335 8.19117 27.989 9.21147C27.9754 9.6728 27.8955 10.1299 27.7516 10.5688C27.6613 10.8504 27.5322 11.1183 27.3682 11.3651C27.166 11.69 26.9466 12.0041 26.7109 12.3062C26.1084 13.1206 25.5607 14.0073 24.9034 14.8217Z" fill="#999999"></path><path d="M16.7058 7.58268C15.8382 5.99003 14.5344 4.67263 12.9447 3.78217L10.9546 2.69631C10.9546 2.69631 13.2551 -0.778436 16.1945 0.162641C19.134 1.10372 18.1846 7.4017 17.5821 9.80869" fill="#4D4D4D"></path><path d="M20.3209 41.6243C17.4179 40.4118 16.2129 38.3668 14.6975 36.919C13.1821 35.4711 12.8717 29.3903 13.1638 24.6126C13.456 19.8348 17.4909 11.528 17.5822 9.80869C17.6735 8.08941 15.4643 5.17569 13.5655 3.78217C11.6491 2.2631 9.29769 1.38272 6.84668 1.2666L8.36207 2.51534C9.74965 3.67359 9.42101 3.98125 9.22018 6.26155C9.01935 8.54185 8.72722 15.6904 8.70896 21.8436C8.70896 30.3495 6.73713 32.7022 13.0178 38.8373C14.1564 40.1358 15.6863 41.0368 17.3814 41.4072C21.6902 43.036 24.228 43.2712 20.3209 41.6243Z" fill="#1A1A1A"></path><path d="M17.9839 7.07618C17.5904 9.58823 16.8212 12.0281 15.7016 14.3152C14.6765 16.6746 13.7925 19.0918 13.0543 21.5543C12.076 25.3846 11.8405 29.3642 12.3605 33.2816C12.4325 34.6426 12.8065 35.9712 13.4559 37.1726C14.1362 38.1272 14.9759 38.9596 15.939 39.6338C17.8321 41.3312 20.1651 42.4718 22.6761 42.9276C20.068 40.8547 18.189 38.0165 17.3083 34.8199C16.3002 31.5246 16.6412 27.9684 18.2577 24.9205C18.7142 24.0699 19.2436 23.2555 19.7731 22.4411L24.4653 15.3287C24.7022 15.0187 24.8815 14.6694 24.9948 14.2971C25.0769 13.891 25.0769 13.4727 24.9948 13.0665C24.3347 9.48034 22.792 6.11109 20.5034 3.25758C19.9266 2.35717 19.1529 1.59688 18.2395 1.033C17.3262 0.46911 16.2966 0.116066 15.2269 0C15.7121 0.03052 16.1783 0.198543 16.5699 0.484084C16.9616 0.769625 17.2622 1.16066 17.4361 1.61069C17.8159 2.51034 18.0085 3.47679 18.0021 4.45202C18.0507 5.32627 18.0446 6.20267 17.9839 7.07618Z" fill="#808080"></path><path d="M34.927 21.7174C34.8742 21.5895 34.8068 21.4681 34.7261 21.3554C34.5725 21.0145 34.3893 20.6875 34.1784 20.3781C34.0141 20.1429 33.8315 19.9257 33.6489 19.7085C33.2107 19.1294 33.0829 18.3874 32.5352 17.8988C32.2726 17.6504 32.0907 17.33 32.0126 16.9787C31.9346 16.6273 31.964 16.2609 32.097 15.9261C32.2066 15.6366 32.4074 15.4013 32.5352 15.1298C32.6706 14.7258 32.7195 14.2982 32.6786 13.8744C32.6378 13.4505 32.5081 13.0398 32.2979 12.6685C31.7956 11.6016 31.1838 10.5888 30.4721 9.64624C29.5227 8.32511 28.5185 7.05828 27.4596 5.82764C27.6672 6.89431 27.6423 7.99266 27.3865 9.04902C27.2386 9.62495 27.0432 10.1879 26.8023 10.7321C26.4264 11.4007 26.0118 12.0473 25.5608 12.6685C23.2238 16.2881 20.832 19.9076 18.349 23.4004C17.0435 25.5573 16.3321 28.0161 16.2859 30.5309C16.0848 32.9993 16.618 35.472 17.8195 37.6433C18.5687 38.8742 19.4502 40.021 20.4486 41.0637C21.0694 41.7334 21.7814 42.8735 22.6395 43.0726C22.7491 42.041 22.9499 40.6475 23.096 39.6159C23.3338 37.934 23.8782 36.3089 24.7027 34.8201C25.1895 33.7601 26.0543 32.9158 27.1309 32.4493C27.9135 32.2862 28.7218 32.2862 29.5044 32.4493C29.9422 32.4221 30.3812 32.4221 30.819 32.4493C31.2686 32.4735 31.7149 32.3597 32.097 32.1235C32.3186 31.968 32.5024 31.7655 32.6351 31.5307C32.7677 31.2959 32.8459 31.0347 32.8638 30.7662C32.9186 30.2791 32.9186 29.7874 32.8638 29.3003C32.8245 28.9868 32.8685 28.6686 32.9916 28.3773C33.2473 27.8525 34.0141 27.6172 34.0689 27.02C34.0476 26.7523 33.9665 26.4927 33.8315 26.2599C33.7604 26.1456 33.7228 26.014 33.7228 25.8798C33.7228 25.7456 33.7604 25.614 33.8315 25.4998C33.8315 25.4998 34.0506 25.355 34.1236 25.2464C34.2051 25.1396 34.2492 25.0093 34.2492 24.8754C34.2492 24.7415 34.2051 24.6112 34.1236 24.5044C33.9428 24.2955 33.8006 24.0566 33.7037 23.7986C33.695 23.6656 33.715 23.5323 33.7622 23.4075C33.8094 23.2827 33.8828 23.1692 33.9776 23.0747C34.1732 22.888 34.3945 22.7295 34.6348 22.6041C34.7511 22.5516 34.8541 22.4739 34.9362 22.3769C35.0183 22.2798 35.0776 22.1658 35.1095 22.0431C35.0688 21.9246 35.0069 21.8143 34.927 21.7174Z" fill="#CCCCCC"></path><path d="M34.3062 20.5771C34.478 20.8248 34.619 21.0922 34.7261 21.3734C34.8037 21.4816 34.8709 21.5967 34.9269 21.7173L34.3062 20.5771Z" fill="#CCCCCC"></path><path d="M10.133 33.4262C9.0523 28.5693 8.7138 23.5789 9.12886 18.6223C9.12886 16.1429 11.265 2.44302 7.79605 1.41145C4.85656 0.524668 2.53783 3.94512 2.53783 3.94512C0.667683 7.68216 -0.206002 11.8316 1.36513e-05 15.9982C2.30048 38.8193 17.6735 41.4615 18.2577 41.7149C18.2577 41.7149 11.4476 39.2898 10.133 33.4262Z" fill="#09212A"></path></g><defs><clipPath id="clip0_917_3082"><rect width="35" height="43"></rect></clipPath></defs></svg></div><div class="Styles_searchBox__5X2m1"><div class="Styles_container__ddCFx "><div class="logos-search-box Styles_searchBox__xWHyX"><div><input type="text" placeholder="Search Vac Research" value=""/></div></div></div></div></div></header><div class="page-info"><h1 style="display:none">Vac Research</h1><div class="page-info-sub"><i>Mar 16 2023</i><br/><span>staging.vac.dev</span></div></div><main class="undefined Styles_common_main__4v7gP Styles_common_main__4v7gP"><aside class="Styles_container__3yUcn Style_sidebar__mLS5A Styles_common_sidebar__QAVov hidden-scroll Styles_hideDesktopToggleButton__L_Rik"><div class="sidebar-toggle-button button Styles_mobile___qAwf"><svg width="16" height="16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 4h14c.55 0 1-.45 1-1s-.45-1-1-1H1c-.55 0-1 .45-1 1s.45 1 1 1Zm14 8H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1Zm0-5H1c-.55 0-1 .45-1 1s.45 1 1 1h14c.55 0 1-.45 1-1s-.45-1-1-1Z" fill="#F2F2F2"></path></svg></div><div class="logo-holder button vac" style="display:inline-block"><svg width="45" height="43" viewBox="0 0 35 43" fill="none" xmlns="http://www.w3.org/2000/svg" class="vac-logo"><g clip-path="url(#clip0_917_3082)"><path d="M24.9034 14.8217C24.6824 11.2666 23.5308 7.8298 21.5623 4.84994C22.543 4.19721 23.7374 3.93844 24.9034 4.12603C25.492 4.23064 26.0472 4.4722 26.5233 4.83086C26.9994 5.18951 27.3828 5.65504 27.6421 6.18916C28.0141 7.1512 28.1335 8.19117 27.989 9.21147C27.9754 9.6728 27.8955 10.1299 27.7516 10.5688C27.6613 10.8504 27.5322 11.1183 27.3682 11.3651C27.166 11.69 26.9466 12.0041 26.7109 12.3062C26.1084 13.1206 25.5607 14.0073 24.9034 14.8217Z" fill="#999999"></path><path d="M16.7058 7.58268C15.8382 5.99003 14.5344 4.67263 12.9447 3.78217L10.9546 2.69631C10.9546 2.69631 13.2551 -0.778436 16.1945 0.162641C19.134 1.10372 18.1846 7.4017 17.5821 9.80869" fill="#4D4D4D"></path><path d="M20.3209 41.6243C17.4179 40.4118 16.2129 38.3668 14.6975 36.919C13.1821 35.4711 12.8717 29.3903 13.1638 24.6126C13.456 19.8348 17.4909 11.528 17.5822 9.80869C17.6735 8.08941 15.4643 5.17569 13.5655 3.78217C11.6491 2.2631 9.29769 1.38272 6.84668 1.2666L8.36207 2.51534C9.74965 3.67359 9.42101 3.98125 9.22018 6.26155C9.01935 8.54185 8.72722 15.6904 8.70896 21.8436C8.70896 30.3495 6.73713 32.7022 13.0178 38.8373C14.1564 40.1358 15.6863 41.0368 17.3814 41.4072C21.6902 43.036 24.228 43.2712 20.3209 41.6243Z" fill="#1A1A1A"></path><path d="M17.9839 7.07618C17.5904 9.58823 16.8212 12.0281 15.7016 14.3152C14.6765 16.6746 13.7925 19.0918 13.0543 21.5543C12.076 25.3846 11.8405 29.3642 12.3605 33.2816C12.4325 34.6426 12.8065 35.9712 13.4559 37.1726C14.1362 38.1272 14.9759 38.9596 15.939 39.6338C17.8321 41.3312 20.1651 42.4718 22.6761 42.9276C20.068 40.8547 18.189 38.0165 17.3083 34.8199C16.3002 31.5246 16.6412 27.9684 18.2577 24.9205C18.7142 24.0699 19.2436 23.2555 19.7731 22.4411L24.4653 15.3287C24.7022 15.0187 24.8815 14.6694 24.9948 14.2971C25.0769 13.891 25.0769 13.4727 24.9948 13.0665C24.3347 9.48034 22.792 6.11109 20.5034 3.25758C19.9266 2.35717 19.1529 1.59688 18.2395 1.033C17.3262 0.46911 16.2966 0.116066 15.2269 0C15.7121 0.03052 16.1783 0.198543 16.5699 0.484084C16.9616 0.769625 17.2622 1.16066 17.4361 1.61069C17.8159 2.51034 18.0085 3.47679 18.0021 4.45202C18.0507 5.32627 18.0446 6.20267 17.9839 7.07618Z" fill="#808080"></path><path d="M34.927 21.7174C34.8742 21.5895 34.8068 21.4681 34.7261 21.3554C34.5725 21.0145 34.3893 20.6875 34.1784 20.3781C34.0141 20.1429 33.8315 19.9257 33.6489 19.7085C33.2107 19.1294 33.0829 18.3874 32.5352 17.8988C32.2726 17.6504 32.0907 17.33 32.0126 16.9787C31.9346 16.6273 31.964 16.2609 32.097 15.9261C32.2066 15.6366 32.4074 15.4013 32.5352 15.1298C32.6706 14.7258 32.7195 14.2982 32.6786 13.8744C32.6378 13.4505 32.5081 13.0398 32.2979 12.6685C31.7956 11.6016 31.1838 10.5888 30.4721 9.64624C29.5227 8.32511 28.5185 7.05828 27.4596 5.82764C27.6672 6.89431 27.6423 7.99266 27.3865 9.04902C27.2386 9.62495 27.0432 10.1879 26.8023 10.7321C26.4264 11.4007 26.0118 12.0473 25.5608 12.6685C23.2238 16.2881 20.832 19.9076 18.349 23.4004C17.0435 25.5573 16.3321 28.0161 16.2859 30.5309C16.0848 32.9993 16.618 35.472 17.8195 37.6433C18.5687 38.8742 19.4502 40.021 20.4486 41.0637C21.0694 41.7334 21.7814 42.8735 22.6395 43.0726C22.7491 42.041 22.9499 40.6475 23.096 39.6159C23.3338 37.934 23.8782 36.3089 24.7027 34.8201C25.1895 33.7601 26.0543 32.9158 27.1309 32.4493C27.9135 32.2862 28.7218 32.2862 29.5044 32.4493C29.9422 32.4221 30.3812 32.4221 30.819 32.4493C31.2686 32.4735 31.7149 32.3597 32.097 32.1235C32.3186 31.968 32.5024 31.7655 32.6351 31.5307C32.7677 31.2959 32.8459 31.0347 32.8638 30.7662C32.9186 30.2791 32.9186 29.7874 32.8638 29.3003C32.8245 28.9868 32.8685 28.6686 32.9916 28.3773C33.2473 27.8525 34.0141 27.6172 34.0689 27.02C34.0476 26.7523 33.9665 26.4927 33.8315 26.2599C33.7604 26.1456 33.7228 26.014 33.7228 25.8798C33.7228 25.7456 33.7604 25.614 33.8315 25.4998C33.8315 25.4998 34.0506 25.355 34.1236 25.2464C34.2051 25.1396 34.2492 25.0093 34.2492 24.8754C34.2492 24.7415 34.2051 24.6112 34.1236 24.5044C33.9428 24.2955 33.8006 24.0566 33.7037 23.7986C33.695 23.6656 33.715 23.5323 33.7622 23.4075C33.8094 23.2827 33.8828 23.1692 33.9776 23.0747C34.1732 22.888 34.3945 22.7295 34.6348 22.6041C34.7511 22.5516 34.8541 22.4739 34.9362 22.3769C35.0183 22.2798 35.0776 22.1658 35.1095 22.0431C35.0688 21.9246 35.0069 21.8143 34.927 21.7174Z" fill="#CCCCCC"></path><path d="M34.3062 20.5771C34.478 20.8248 34.619 21.0922 34.7261 21.3734C34.8037 21.4816 34.8709 21.5967 34.9269 21.7173L34.3062 20.5771Z" fill="#CCCCCC"></path><path d="M10.133 33.4262C9.0523 28.5693 8.7138 23.5789 9.12886 18.6223C9.12886 16.1429 11.265 2.44302 7.79605 1.41145C4.85656 0.524668 2.53783 3.94512 2.53783 3.94512C0.667683 7.68216 -0.206002 11.8316 1.36513e-05 15.9982C2.30048 38.8193 17.6735 41.4615 18.2577 41.7149C18.2577 41.7149 11.4476 39.2898 10.133 33.4262Z" fill="#09212A"></path></g><defs><clipPath id="clip0_917_3082"><rect width="35" height="43"></rect></clipPath></defs></svg></div><div class="Styles_desktop__VH2y3 defaultSidebar Styles_container__4YC7p"><nav class="sidebarNav hidden-scroll"><ul class="sidebar-menu mainMenu Styles_menu__izFC1"><li class="Styles_menuItem__BqRqE menuitem level-0"><span></span><ul class="sidebar-menu  Styles_menu__izFC1"><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="Main" href="/">Main</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="principles" href="/principles">Principles</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="Research areas" href="/research-areas">Research areas</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="Projects" href="/projects">Projects</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="Open Research Problems" href="/open-problems">Open Research Problems</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="publications" href="/publications">Publications</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="contribute" href="/contribute">Contribute</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="media" href="/media">Media</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li></ul><br/></li></ul><br/><ul class="sidebar-menu subMenu Styles_menu__izFC1"><li class="Styles_menuItem__BqRqE menuitem level-0"><a class="" title="research" href="/research">Research</a><ul class="sidebar-menu  Styles_menu__izFC1"><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="Waku for All Decentralized Applications and Infrastructures" href="/waku-for-all">Waku for All Decentralized Applications and Infrastructures</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="Building Privacy-Protecting Infrastructure" href="/building-privacy-protecting-infrastructure">Building Privacy-Protecting Infrastructure</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="Waku Privacy and Anonymity Analysis Part I: Definitions and Waku Relay" href="/wakuv2-relay-anon">Waku Privacy and Anonymity Analysis Part I: Definitions and Waku Relay</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="active" title="Noise handshakes as key-exchange mechanism for Waku" href="/wakuv2-noise">Noise handshakes as key-exchange mechanism for Waku</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="Waku v2 Ambient Peer Discovery" href="/wakuv2-apd">Waku v2 Ambient Peer Discovery</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="Introducing nwaku" href="/introducing-nwaku">Introducing nwaku</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li class="Styles_menuItem__BqRqE menuitem level-1"><a class="" title="Opinion: Pseudo-ethics in the Surveillance Tech Industry" href="/ethics-surveillance-tech">Opinion: Pseudo-ethics in the Surveillance Tech Industry</a><ul class="sidebar-menu  Styles_menu__izFC1"></ul></li><li><span class="button">...</span></li></ul><br/></li></ul><div class="external_links"><div><div class="menuitem-title"><span class="cap">Resources</span></div><ul><li><a href="https://rfc.vac.dev/" target="_blank">&gt; Specs/RFCs</a></li><li><a href="https://forum.vac.dev/" target="_blank">&gt; Forum</a></li><li><a href="https://waku.org" target="_blank">&gt; Waku.org</a></li></ul></div></div></nav></div></aside><article class="Styles_container__pG0bG Style_content__NTXHZ Styles_common_content__Myi5Z"><div class="Style_container__qc2tD"><h2 class="Style_container__eSI4Q serif">Noise handshakes as key-exchange mechanism for Waku</h2><div class="serif"><i>May 17 2022</i><i> - </i>by<!-- --><a title="s1fr0" href="/authors/s1fr0"><span><i> <!-- -->s1fr0<!-- --></i></span></a></div></div><h1><a class="anchor" id="introduction"></a><a class="ha" href="#introduction">Introduction<!-- --></a></h1>
<!-- --><p>In this post we will provide an overview of how <!-- --><a href="https://rfc.vac.dev/spec/10/">Waku v2<!-- --></a> users can adopt <!-- --><a href="http://www.noiseprotocol.org/noise.html">Noise handshakes<!-- --></a> to agree on cryptographic keys used to securely encrypt messages.<!-- --></p>
<!-- --><p>This process belongs to the class of <!-- --><em>key-exchange<!-- --></em> mechanisms, consisting of all those protocols that, with different levels of complexity and security guarantees, allow two parties to publicly agree on a secret without letting anyone else know what this secret is.<!-- --></p>
<!-- --><p>But why do we need key-exchange mechanisms in the first place?<!-- --></p>
<!-- --><p>With the advent of <!-- --><a href="https://en.wikipedia.org/wiki/Public-key_cryptography">public-key cryptography<!-- --></a>, it become possible to decouple encryption from decryption through use of two distinct cryptographic keys: one <!-- --><em>public<!-- --></em>, used to encrypt information and that can be made available to anyone, and one <!-- --><em>private<!-- --></em> (kept secret), which enables decryption of messages encrypted with its corresponding public key. The same does not happen in the case of <!-- --><a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">symmetric encryption schemes<!-- --></a> where, instead, the same key is used for both encryption and decryption operations and hence cannot be publicly revealed as for public keys.<!-- --></p>
<!-- --><p>In order to address specific application needs, many different public, symmetric and hybrid cryptographic schemes were designed: <!-- --><a href="https://rfc.vac.dev/spec/6/">Waku v1<!-- --></a> and <!-- --><a href="https://rfc.vac.dev/spec/10/">Waku v2<!-- --></a>, which inherits part of their design from the Ethereum messaging protocol <!-- --><a href="https://ethereum.org/en/developers/docs/networking-layer/#whisper">Whisper<!-- --></a>, provide <!-- --><a href="https://rfc.vac.dev/spec/26/">support<!-- --></a> to both public-key primitives (<!-- --><a href="https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme"><code>ECIES</code></a>, <!-- --><a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"><code>ECDSA</code></a>) and symmetric primitives (<!-- --><a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode"><code>AES-256-GCM</code></a>, <!-- --><a href="https://en.wikipedia.org/wiki/SHA-3"><code>KECCAK-256</code></a>), used to sign, hash, encrypt and decrypt exchanged messages.<!-- --></p>
<!-- --><p>In principle, when communications employ public-key based encryption schemes (<!-- --><code>ECIES</code>, in the case of Waku), there is no need for a key-agreement among parties: messages can be directly encrypted using the recipient&#x27;s public-key before being sent over the network. However, public-key encryption and decryption primitives are usually very inefficient in processing large amount of data, and this may constitute a bottleneck for many of today&#x27;s applications. Symmetric encryption schemes such as <!-- --><code>AES-256-GCM</code>, on the other hand, are much more efficient, but the encryption/decryption key needs to be shared among users beforehand any encrypted messages is exchanged.<!-- --></p>
<!-- --><p>To counter the downsides given by each of these two approaches while taking advantage of their strengths, hybrid constructions were designed. In these, public-key primitives are employed to securely agree on a secret key which, in turn, is used with a symmetric cipher for encrypting messages. In other words, such constructions specify a (public-key based) key-agreement mechanism!<!-- --></p>
<!-- --><p>Waku, up to <!-- --><a href="https://rfc.vac.dev/spec/14/#payload-encryption">payload version 1<!-- --></a>, does not implement nor recommend any protocol for exchanging symmetric ciphers&#x27; keys, leaving such task to the application layer. It is important to note that the kind of key-agreement employed has a direct impact on the security properties that can be granted on later encrypted messages, while security requirements usually depend on the specific application for which encryption is needed in the first place.<!-- --></p>
<!-- --><p>In this regard, <!-- --><a href="https://status.im">Status<!-- --></a>, which  builds on top of Waku, <!-- --><a href="https://specs.status.im/spec/5">implements<!-- --></a> a custom version of the <!-- --><a href="https://signal.org/docs/specifications/x3dh/">X3DH<!-- --></a> key-agreement protocol, in order to allow users to instantiate end-to-end encrypted communication channels. However, although such a solution is optimal when applied to (distributed) E2E encrypted chats, it is not flexible enough to fit or simplify the variety of applications Waku aims to address.
Hence, proposing and implementing one or few key-agreements which provide certain (presumably <!-- --><em>strong<!-- --></em>) security guarantees, would inevitably degrade performances of all those applications for which, given their security requirements, more tailored and efficient key-exchange mechanisms can be employed.<!-- --></p>
<!-- --><p>Guided by different examples, in the following sections we will overview Noise, a protocol framework we are <!-- --><a href="https://rfc.vac.dev/spec/35/">currently integrating<!-- --></a> in Waku, for building secure key-agreements between two parties. One of the great advantage of using Noise is that it is possible to add support to new key-exchanges by just specifying users&#x27; actions from a predefined list, requiring none to minimal modifications to existing implementations. Furthermore, Noise provides a framework to systematically analyze protocols&#x27; security properties and the corresponding attacker threat models. This allows not only to easily design new key-agreements eventually optimized for specific applications we want to address, but also to easily analyze or even <!-- --><a href="https://noiseexplorer.com/">formally verify<!-- --></a> any of such custom protocol!<!-- --></p>
<!-- --><p>We believe that with its enormous flexibility and features, Noise represents a perfect candidate for bringing key-exchange mechanisms in Waku.<!-- --></p>
<!-- --><h2><a class="anchor" id="the-diffie-hellman-key-exchange"></a><a class="ha" href="#the-diffie-hellman-key-exchange">The Diffie-Hellman Key-exchange<!-- --></a></h2>
<!-- --><p>The formalization of modern public-key cryptography started with the pioneering work of Whitefield Diffie and Martin Hellman, who detailed one of the earliest known key-agreement protocols: the famous <!-- --><a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie-Hellman Key-Exchange<!-- --></a>.<!-- --></p>
<!-- --><p>Diffie-Hellman (DH) key-exchange is largely used today and represents the main cryptographic building block on which Noise handshakes&#x27; security is based.<!-- --></p>
<!-- --><p>In turn, the security of DH is based on a mathematical problem called <!-- --><a href="https://en.wikipedia.org/wiki/Discrete_logarithm">discrete logarithm<!-- --></a> which is believed to be hard when the agreement is practically instantiated using certain <!-- --><a href="https://en.wikipedia.org/wiki/Elliptic_curve">elliptic curves<!-- --></a> <!-- --><span><span style="display:inline">$E$</span></span> defined over finite fields <!-- --><span><span style="display:inline">$\mathbb{F}_p$</span></span>.<!-- --></p>
<!-- --><p>Informally, a DH exchange between Alice and Bob proceeds as follows:<!-- --></p>
<!-- --><ul>
<!-- --><li>Alice picks a secret scalar <!-- --><span><span style="display:inline">$s_A\in\mathbb{F}_p$</span></span> and computes, using the underlying <!-- --><a href="https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication">curve&#x27;s arithmetic<!-- --></a>, the point <!-- --><span><span style="display:inline">$P_A = s_A\cdot P\in E(\mathbb{F}_p)$</span></span> for a certain pre-agreed public generator <!-- --><span><span style="display:inline">$P$</span></span> of the elliptic curve <!-- --><span><span style="display:inline">$E(\mathbb{F}_p)$</span></span>. She then sends <!-- --><span><span style="display:inline">$P_A$</span></span> to Bob.<!-- --></li>
<!-- --><li>Similarly, Bob picks a secret scalar <!-- --><span><span style="display:inline">$s_B\in\mathbb{F}_p$</span></span>, computes <!-- --><span><span style="display:inline">$P_B = s_B\cdot P\in E(\mathbb{F}_p)$</span></span> and sends <!-- --><span><span style="display:inline">$P_B$</span></span> to Alice.<!-- --></li>
<!-- --><li>By commutativity of scalar multiplication, both Alice and Bob can now compute the point <!-- --><span><span style="display:inline">$P_{AB} = s_As_B\cdot P$</span></span>, using the elliptic curve point received from the other party and their secret scalar.<!-- --></li>
<!-- --></ul>
<!-- --><p>The assumed hardness of computing discrete logarithms in the elliptic curve, ensures that it is not possible to compute <!-- --><span><span style="display:inline">$s_A$</span></span> or <!-- --><span><span style="display:inline">$s_B$</span></span> from <!-- --><span><span style="display:inline">$P_A$</span></span> and <!-- --><span><span style="display:inline">$P_B$</span></span>, respectively. Another security assumption (named <!-- --><a href="https://en.wikipedia.org/wiki/Computational_Diffie%E2%80%93Hellman_assumption">Computational Diffie-Hellman assumption<!-- --></a>) ensures that it is not possible to compute <!-- --><span><span style="display:inline">$P_{AB}$</span></span> from <!-- --><span><span style="display:inline">$P$</span></span>, <!-- --><span><span style="display:inline">$P_A$</span></span> and <!-- --><span><span style="display:inline">$P_B$</span></span>. Hence the point <!-- --><span><span style="display:inline">$P_{AB}$</span></span> shared by Alice and Bob at the end of the above protocol cannot be efficiently computed by an attacker intercepting <!-- --><span><span style="display:inline">$P_A$</span></span> and <!-- --><span><span style="display:inline">$P_B$</span></span>, and can then be used to generate a secret to be later employed, for example, as a symmetric encryption key.<!-- --></p>
<!-- --><p>On a side note, this protocol shows the interplay between two components typical to public-key based schemes: the scalars <!-- --><span><span style="display:inline">$s_A$</span></span> and <!-- --><span><span style="display:inline">$s_B$</span></span> can be seen as <!-- --><em>private keys<!-- --></em> associated to the <!-- --><em>public keys<!-- --></em> <!-- --><span><span style="display:inline">$P_A$</span></span> and <!-- --><span><span style="display:inline">$P_B$</span></span>, respectively, which allow Alice and Bob only to compute the shared secret point <!-- --><span><span style="display:inline">$P_{AB}$</span></span>.<!-- --></p>
<!-- --><h2><a class="anchor" id="ephemeral-and-static-public-keys"></a><a class="ha" href="#ephemeral-and-static-public-keys">Ephemeral and Static Public Keys<!-- --></a></h2>
<!-- --><p>Although we assumed that it is practically impossible for an attacker to compute the randomly picked secret scalar from the corresponding public elliptic curve point, it may happen that such scalar gets compromised or can be guessed due to a faulty employed random number generator. In such cases, an attacker will be able to recover the final shared secret and all encryption keys eventually derived from that, with clear catastrophic consequences for the privacy of exchanged messages.<!-- --></p>
<!-- --><p>To mitigate such issues, multiple DH operations can be combined using two different types of exchanged elliptic curve points or, better, <!-- --><em>public keys<!-- --></em>: <!-- --><em>ephemeral keys<!-- --></em>, that is random keys used only once in a DH operation, and long-term <!-- --><em>static keys<!-- --></em>, used mainly for authentication purposes since employed multiple times.<!-- --></p>
<!-- --><p>Just to provide an example, let us suppose Alice and Bob perform the following custom DH-based key-exchange protocol:<!-- --></p>
<!-- --><ul>
<!-- --><li>Alice generates an ephemeral key <!-- --><span><span style="display:inline">$E_A=e_A\cdot P$</span></span> by picking a random scalar <!-- --><span><span style="display:inline">$e_A$</span></span> and sends <!-- --><span><span style="display:inline">$E_A$</span></span> to Bob;<!-- --></li>
<!-- --><li>Similarly, Bob generates an ephemeral key <!-- --><span><span style="display:inline">$E_B=e_B\cdot P$</span></span> and sends <!-- --><span><span style="display:inline">$E_B$</span></span> to Alice;<!-- --></li>
<!-- --><li>Alice and Bob computes <!-- --><span><span style="display:inline">$E_{AB} = e_Ae_B \cdot P$</span></span> and from it derive a secret encryption key <!-- --><span><span style="display:inline">$k$</span></span>.<!-- --></li>
<!-- --><li>Bob sends to Alice his static key <!-- --><span><span style="display:inline">$S_B = s_B\cdot P$</span></span> encrypted with <!-- --><span><span style="display:inline">$k$</span></span>.<!-- --></li>
<!-- --><li>Alice encrypts with <!-- --><span><span style="display:inline">$k$</span></span> her static key <!-- --><span><span style="display:inline">$S_A = s_A\cdot P$</span></span> and sends it to Bob.<!-- --></li>
<!-- --><li>Alice and Bob decrypt the received static keys, compute the secret <!-- --><span><span style="display:inline">$S_{AB} = s_As_B \cdot P$</span></span> and use it together with <!-- --><span><span style="display:inline">$E_{AB}$</span></span> to derive a new encryption key <!-- --><span><span style="display:inline">$\tilde{k}$</span></span> to be later used with a symmetric cipher.<!-- --></li>
<!-- --></ul>
<!-- --><p>In this protocol, if Alice&#x27;s and/or Bob&#x27;s static keys get compromised, it would not possible to derive the final secret key <!-- --><span><span style="display:inline">$\tilde{k}$</span></span>, since at least one ephemeral key among <!-- --><span><span style="display:inline">$E_A$</span></span> and <!-- --><span><span style="display:inline">$E_B$</span></span> has to be compromised too in order to recover the secret <!-- --><span><span style="display:inline">$E_{AB}$</span></span>. Furthermore, since Alice&#x27;s and Bob&#x27;s long-term static keys are encrypted, an attacker intercepting exchanged (encrypted) public keys will not be able to link such communication to Alice or Bob, unless one of the ephemeral key is compromised (and, even in such case, none of the messages encrypted under the key <!-- --><span><span style="display:inline">$\tilde{k}$</span></span> can be decrypted).<!-- --></p>
<!-- --><h1><a class="anchor" id="the-noise-protocol-framework"></a><a class="ha" href="#the-noise-protocol-framework">The Noise Protocol Framework<!-- --></a></h1>
<!-- --><p>In previous section we gave a small intuition on how multiple DH operations over ephemeral and static users&#x27; public keys can be combined to create different key-exchange protocols.<!-- --></p>
<!-- --><p>The <!-- --><a href="http://www.noiseprotocol.org/noise.html">Noise Protocol Framework<!-- --></a>, defines various rules for building custom key-exchange protocols while allowing easy analysis of the security properties and threat models provided given the type and order of the DH operations employed.<!-- --></p>
<!-- --><p>In Noise terminology, a key-agreement or <!-- --><em>Noise protocol<!-- --></em> consists of one or more <!-- --><em>Noise handshakes<!-- --></em>. During a Noise handshake, Alice and Bob exchange multiple (handshake) messages containing their ephemeral keys and/or static keys. These public keys are then used to perform a handshake-dependent sequence of Diffie-Hellman operations, whose results are all hashed into a shared secret key. Similarly as we have seen above, after a handshake is complete, each party will use the derived secret key to send and receive <!-- --><a href="https://en.wikipedia.org/wiki/Authenticated_encryption">authenticated encrypted data<!-- --></a> by employing a symmetric cipher.<!-- --></p>
<!-- --><p>Depending on the <!-- --><em>handshake pattern<!-- --></em> adopted, different security guarantees can be provided on messages encrypted using a handshake-derived key.<!-- --></p>
<!-- --><p>The Noise handshakes we support in Waku all provide the following security properties:<!-- --></p>
<!-- --><ul>
<!-- --><li><strong>Confidentiality<!-- --></strong>: the adversary should not be able to learn what data is being sent between Alice and Bob.<!-- --></li>
<!-- --><li><strong>Strong forward secrecy<!-- --></strong>: an active adversary cannot decrypt messages nor infer any information on the employed encryption key, even in the case he has access to Alice&#x27;s and Bob&#x27;s long-term private keys (during or after their communication).<!-- --></li>
<!-- --><li><strong>Authenticity<!-- --></strong>: the adversary should not be able to cause either Alice or Bob to accept messages coming from a party different than their original senders.<!-- --></li>
<!-- --><li><strong>Integrity<!-- --></strong>: the adversary should not be able to cause Alice or Bob to accept data that has been tampered with.<!-- --></li>
<!-- --><li><strong>Identity-hiding<!-- --></strong>: once a secure communication channel is established, a passive adversary should not be able to link exchanged encrypted messages to their corresponding sender and recipient by knowing their long-term static keys.<!-- --></li>
<!-- --></ul>
<!-- --><p>We refer to <!-- --><a href="http://www.noiseprotocol.org/noise.html">Noise specification<!-- --></a> for more formal security definitions and precise threat models relative to Waku <!-- --><a href="/wakuv2-noise#Supported-Noise-Handshakes-in-Waku">supported Noise Handshake patterns<!-- --></a>.<!-- --></p>
<!-- --><h2><a class="anchor" id="message-patterns"></a><a class="ha" href="#message-patterns">Message patterns<!-- --></a></h2>
<!-- --><p>Noise handshakes involving DH operations over ephemeral and static keys can be succinctly sketched using the following set of <!-- --><em>handshake message tokens<!-- --></em>: <!-- --><code>e</code>,<!-- --><code>s</code>,<!-- --><code>ee</code>,<!-- --><code>se</code>,<!-- --><code>es</code>,<!-- --><code>ss</code>.<!-- --></p>
<!-- --><p>Tokens employing single letters denote (the type of) users&#x27; public keys: <!-- --><code>e</code> refers to randomly generated ephemeral key(s), while <!-- --><code>s</code> indicates the users&#x27; long-term static key(s).<!-- --></p>
<!-- --><p>Two letters tokens, instead, denotes DH operations over the two users&#x27; public keys the token refers to, given that the left token letter refers to the handshake <!-- --><em>initiator&#x27;s<!-- --></em> public key, while the right token letter indicates the used <!-- --><em>responder&#x27;s<!-- --></em> public key. Thus, if Alice started a handshake with Bob, the <!-- --><code>es</code> token will shortly represent a DH operation among Alice&#x27;s ephemeral key <!-- --><code>e</code> and Bob&#x27;s static key <!-- --><code>s</code>.<!-- --></p>
<!-- --><p>Since, in order to perform any DH operations users need to share (or pre-share) the corresponding public keys, Noise compactly represents messages&#x27; exchanges using the two direction <!-- --><code>-&gt;</code> and <!-- --><code>&lt;-</code>, where the <!-- --><code>-&gt;</code> denotes a message (arbitrary and/or DH public key) from the initiator to the responder, while <!-- --><code>&lt;-</code> the opposite.<!-- --></p>
<!-- --><p>Hence a <!-- --><em>message pattern<!-- --></em> consisting of a direction and one or multiple tokens such as <!-- --><code>&lt;- e, s, es</code>  has to be interpreted one token at a time: in this example, the responder is sending his ephemeral and static key to the initiator and is then executing a DH operation over the initiator&#x27;s ephemeral key <!-- --><code>e</code> (shared in a previously exchanged message pattern) and his static key <!-- --><code>s</code>. On the other hand, such message indicates also that the initiator received the responder&#x27;s ephemeral and static keys <!-- --><code>e</code> and <!-- --><code>s</code>, respectively, and performed a DH operation over his ephemeral key and the responder&#x27;s just received static key <!-- --><code>s</code>. In this way, both parties will be able to derive at the end of each message pattern processed the same shared secret, which is eventually used to update any derived symmetric encryption keys computed so far.<!-- --></p>
<!-- --><p>In some cases, DH public keys employed in a handshake are pre-shared before the handshake itself starts. In order to chronologically separate exchanged keys and DH operations performed before and during a handshake, Noise employs the <!-- --><code>...</code> delimiter.<!-- --></p>
<!-- --><p>For example, the following message patterns<!-- --></p>
<!-- --><pre><code>&lt;- e
...
-&gt; e, ee
</code></pre>
<!-- --><p>indicates that the initiator knew the responder&#x27;s ephemeral key before he sends his own ephemeral key and executes a DH operation between both parties ephemeral keys (similarly, the responder receives the initiator&#x27;s ephemeral key and does a <!-- --><code>ee</code> DH operation).<!-- --></p>
<!-- --><p>At this point it should be clear how such notation is able to compactly represent a large variety of DH based key-agreements. Nevertheless, we can easily define additional tokens and processing rules in order to address specific applications and security requirements, such as the <!-- --><a href="http://www.noiseprotocol.org/noise.html#handshake-tokens"><code>psk</code></a> token used to process arbitrary pre-shared key material.<!-- --></p>
<!-- --><p>As an example of Noise flexibility, the custom protocol we detailed <!-- --><a href="/wakuv2-noise#Ephemeral-and-Static-Public-Keys">above<!-- --></a> can be shortly represented as <!-- --><em>(Alice is on the left)<!-- --></em>:<!-- --></p>
<!-- --><pre><code>-&gt; e
&lt;- e, ee, s
-&gt; s, ss
</code></pre>
<!-- --><p>where after each DH operation an encryption key is derived (along with the secrets computed by all previously executed DH operations) in order to encrypt/decrypt any subsequent sent/received message.<!-- --></p>
<!-- --><p>Another example is given by the possibility to replicate within Noise the well established Signal&#x27;s <!-- --><a href="https://signal.org/docs/specifications/x3dh/">X3DH<!-- --></a> key-agreement protocols, thus making the latter a general framework to design and study security of many practical and widespread DH-based key-exchange protocols.<!-- --></p>
<!-- --><h2><a class="anchor" id="the-noise-state-objects"></a><a class="ha" href="#the-noise-state-objects">The Noise State Objects<!-- --></a></h2>
<!-- --><p>We mentioned multiple times that parties derive an encryption key each time they perform a DH operation, but how does this work in more details?<!-- --></p>
<!-- --><p>Noise defines three <!-- --><em>state object<!-- --></em>: a <!-- --><em>Handshake State<!-- --></em>, a <!-- --><em>Symmetric State<!-- --></em> and a <!-- --><em>Cipher State<!-- --></em>, each encapsulated into each other and instantiated during the execution of a handshake.<!-- --></p>
<!-- --><p>The Handshake State object stores the user&#x27;s and other party&#x27;s received ephemeral and static keys (if any) and embeds a Symmetric State object.<!-- --></p>
<!-- --><p>The Symmetric State, instead, stores a handshake hash value <!-- --><code>h</code>, iteratively updated with any message read/received and DH secret computed, and a chaining key <!-- --><code>ck</code>, updated using a key derivation function every time a DH secret is computed. This object further embeds a Cipher State.<!-- --></p>
<!-- --><p>Lastly, the Cipher State stores a symmetric encryption <!-- --><code>k</code> key and a counter <!-- --><code>n</code>  used to encrypt and decrypt messages exchanged during the handshake (not only static keys, but also arbitrary payloads). These key and counter are refreshed every time the chaining key is updated.<!-- --></p>
<!-- --><p>While processing each handshake&#x27;s message pattern token, all these objects are updated according to some specific <!-- --><em>processing rules<!-- --></em> which employ a combination of public-key primitives, hash and key-derivation functions and symmetric ciphers. It is important to note, however, that at the end of each processed message pattern, the two users will share the same Symmetric and Cipher State embedded in their respective Handshake States.<!-- --></p>
<!-- --><p>Once a handshake is complete, users derive two new Cipher States and can then discard the Handshake State object (and, thus, the embedded Symmetric State and Cipher State objects)
employed during the handshake.<!-- --></p>
<!-- --><p>These two Cipher states are used to encrypt and decrypt all outbound and inbound after-handshake messages, respectively, and only to these will be granted the confidentiality, authenticity, integrity and identity-hiding properties we detailed above.<!-- --></p>
<!-- --><p>For more details on processing rules, we refer to <!-- --><a href="http://www.noiseprotocol.org/noise.html">Noise specifications<!-- --></a>.<!-- --></p>
<!-- --><h1><a class="anchor" id="supported-noise-handshakes-in-waku"></a><a class="ha" href="#supported-noise-handshakes-in-waku">Supported Noise Handshakes in Waku<!-- --></a></h1>
<!-- --><p>The Noise handshakes we provided support to in Waku address four typical scenarios occurring when an encrypted communication channel between Alice and Bob is going to be created:<!-- --></p>
<!-- --><ul>
<!-- --><li>Alice and Bob know each others&#x27; static key.<!-- --></li>
<!-- --><li>Alice knows Bob&#x27;s static key;<!-- --></li>
<!-- --><li>Alice and Bob share no key material and they don&#x27;t know each others&#x27; static key.<!-- --></li>
<!-- --><li>Alice and Bob share some key material, but they don&#x27;t know each others&#x27; static key.<!-- --></li>
<!-- --></ul>
<!-- --><p>The possibility to have handshakes based on the reciprocal knowledge parties have of each other, allows designing Noise handshakes that can quickly reach the desired level of security on exchanged encrypted messages while keeping the number of interactions between Alice and Bob minimum.<!-- --></p>
<!-- --><p>Nonetheless, due to the pure <!-- --><em>token-based<!-- --></em> nature of handshake processing rules, implementations can easily add support to any custom handshake pattern with minor modifications, in case more specific application use-cases need to be addressed.<!-- --></p>
<!-- --><p>On a side note, we already mentioned that identity-hiding properties can be guaranteed against a passive attacker that only reads the communication occurring between Alice and Bob. However, an active attacker who compromised one party&#x27;s static key and actively interferes with the parties&#x27; exchanged messages, may lower the identity-hiding security guarantees provided by some handshake patterns. In our security model we exclude such adversary, but, for completeness, in the following we report a summary of possible de-anonymization attacks that can be performed by such an active attacker.<!-- --></p>
<!-- --><p>For more details on supported handshakes and on how these are implemented in Waku, we refer to <!-- --><a href="https://rfc.vac.dev/spec/35/">35/WAKU2-NOISE<!-- --></a> RFC.<!-- --></p>
<!-- --><h3><a class="anchor" id="the-k1k1-handshake"></a><a class="ha" href="#the-k1k1-handshake">The K1K1 Handshake<!-- --></a></h3>
<!-- --><p>If Alice and Bob know each others&#x27; static key (e.g., these are public or were already exchanged in a previous handshake) , they MAY execute a <!-- --><code>K1K1</code> handshake.  In Noise notation <!-- --><em>(Alice is on the left)<!-- --></em> this can be sketched as:<!-- --></p>
<!-- --><pre><code> K1K1:
    -&gt;  s
    &lt;-  s
       ...
    -&gt;  e
    &lt;-  e, ee, es
    -&gt;  se
</code></pre>
<!-- --><p>We note that here only ephemeral keys are exchanged. This handshake is useful in case Alice needs to instantiate a new separate encrypted communication channel with Bob, e.g. opening multiple parallel connections, file transfers, etc.<!-- --></p>
<!-- --><p><strong>Security considerations on identity-hiding (active attacker)<!-- --></strong>: no static key is transmitted, but an active attacker impersonating Alice can check candidates for Bob&#x27;s static key.<!-- --></p>
<!-- --><h3><a class="anchor" id="the-xk1-handshake"></a><a class="ha" href="#the-xk1-handshake">The XK1 Handshake<!-- --></a></h3>
<!-- --><p>Here, Alice knows how to initiate a communication with Bob and she knows his public static key: such discovery can be achieved, for example, through a publicly accessible register of users&#x27; static keys, smart contracts, or through a previous public/private advertisement of Bob&#x27;s static key.<!-- --></p>
<!-- --><p>A Noise handshake pattern that suits this scenario is <!-- --><code>XK1</code>:<!-- --></p>
<!-- --><pre><code> XK1:
    &lt;-  s
       ...
    -&gt;  e
    &lt;-  e, ee, es
    -&gt;  s, se
</code></pre>
<!-- --><p>Within this handshake, Alice and Bob reciprocally authenticate their static keys <!-- --><code>s</code> using ephemeral keys <!-- --><code>e</code>. We note that while Bob&#x27;s static key is assumed to be known to Alice (and hence is not transmitted), Alice&#x27;s static key is sent to Bob encrypted with a key derived from both parties ephemeral keys and Bob&#x27;s static key.<!-- --></p>
<!-- --><p><strong>Security considerations on identity-hiding (active attacker)<!-- --></strong>: Alice&#x27;s static key is encrypted with forward secrecy to an authenticated party. An active attacker initiating the handshake can check candidates for Bob&#x27;s static key against recorded/accepted exchanged handshake messages.<!-- --></p>
<!-- --><h3><a class="anchor" id="the-xx-and-xxpsk0-handshakes"></a><a class="ha" href="#the-xx-and-xxpsk0-handshakes">The XX and XXpsk0 Handshakes<!-- --></a></h3>
<!-- --><p>If Alice is not aware of any static key belonging to Bob (and neither Bob knows anything about Alice), she can execute an <!-- --><code>XX</code> handshake, where each party tran<!-- --><strong>X<!-- --></strong>mits to the other its own static key.<!-- --></p>
<!-- --><p>The handshake goes as follows:<!-- --></p>
<!-- --><pre><code> XX:
    -&gt;  e
    &lt;-  e, ee, s, es
    -&gt;  s, se
</code></pre>
<!-- --><p>We note that the main difference with <!-- --><code>XK1</code> is that in second step Bob sends to Alice his own static key encrypted with a key obtained from an ephemeral-ephemeral Diffie-Hellman exchange.<!-- --></p>
<!-- --><p>This handshake can be slightly changed in case both Alice and Bob pre-shares some secret <!-- --><code>psk</code> which can be used to strengthen their mutual authentication during the handshake execution. One of the resulting protocol, called <!-- --><code>XXpsk0</code>, goes as follow:<!-- --></p>
<!-- --><pre><code> XXpsk0:
    -&gt;  psk, e
    &lt;-  e, ee, s, es
    -&gt;  s, se
</code></pre>
<!-- --><p>The main difference with <!-- --><code>XX</code> is that Alice&#x27;s and Bob&#x27;s static keys, when transmitted, would be encrypted with a key derived from <!-- --><code>psk</code> as well.<!-- --></p>
<!-- --><p><strong>Security considerations on identity-hiding (active attacker)<!-- --></strong>: Alice&#x27;s static key is encrypted with forward secrecy to an authenticated party for both <!-- --><code>XX</code> and <!-- --><code>XXpsk0</code> handshakes. In <!-- --><code>XX</code>, Bob&#x27;s static key is encrypted with forward secrecy but is transmitted to a non-authenticated user which can then be an active attacker. In <!-- --><code>XXpsk0</code>, instead, Bob&#x27;s secret key is protected by forward secrecy to a partially authenticated party (through the pre-shared secret <!-- --><code>psk</code> but not through any static key), provided that <!-- --><code>psk</code> was not previously compromised (in such case identity-hiding properties provided by the <!-- --><code>XX</code> handshake applies).<!-- --></p>
<!-- --><h1><a class="anchor" id="session-management-and-multi-device-support"></a><a class="ha" href="#session-management-and-multi-device-support">Session Management and Multi-Device Support<!-- --></a></h1>
<!-- --><p>When two users complete a Noise handshake, an encryption/decryption session - or <!-- --><em>Noise session<!-- --></em> - consisting of two Cipher States is instantiated.<!-- --></p>
<!-- --><p>By identifying Noise session with a <!-- --><code>session-id</code> derived from the handshake&#x27;s cryptographic material, we can take advantage of the <!-- --><a href="https://github.com/libp2p/specs/tree/master/pubsub">PubSub/GossipSub<!-- --></a> protocols used by Waku for relaying messages in order to manage instantiated Noise sessions.<!-- --></p>
<!-- --><p>The core idea is to exchange after-handshake messages  (encrypted with a Cipher State specific to the Noise session), over a content topic derived from the (secret) <!-- --><code>session-id</code> the corresponding session refers to.<!-- --></p>
<!-- --><p>This allows to decouple the handshaking phase from the actual encrypted communication, thus improving users&#x27; identity-hiding capabilities.<!-- --></p>
<!-- --><p>Furthermore, by publicly revealing a value derived from <!-- --><code>session-id</code> on the corresponding session content topic, a Noise session can be marked as <!-- --><em>stale<!-- --></em>, enabling peers to save resources by discarding any eventually <!-- --><a href="https://rfc.vac.dev/spec/13/">stored<!-- --></a> message sent to such content topic.<!-- --></p>
<!-- --><p>One relevant aspect in today&#x27;s applications is the possibility for users to employ different devices in their communications. In some cases, this is non-trivial to achieve since, for example, encrypted messages might be required to be synced on different devices which do not necessarily share the necessary key material for  decryption and may be temporarily offline.<!-- --></p>
<!-- --><p>We address this by requiring each user&#x27;s device to instantiate multiple Noise sessions either with all user&#x27;s other devices which, in turn, all together share a Noise session with the other party, or by directly instantiating a Noise session with all other party&#x27;s devices.<!-- --></p>
<!-- --><p>We named these two approaches <!-- --><span><span style="display:inline">$N11M$</span></span> and <!-- --><span><span style="display:inline">$NM$</span></span>, respectively, which are in turn loosely based on the paper <!-- --><a href="https://eprint.iacr.org/2019/1363.pdf">Multi-Device for Signal<!-- --></a> and <!-- --><a href="https://signal.org/docs/specifications/sesame/">Signals Sesame Algorithm<!-- --></a>.<!-- --></p>
<!-- --><figure class="rehype-figure"><img src="/compiled-assets//img/noise/N11M.png" alt=""/></figure>
<!-- --><p>Informally, in the <!-- --><span><span style="display:inline">$N11M$</span></span> session management scheme, once the first Noise session between any of Alices and Bobs device is instantiated, its session information is securely propagated to all other devices using previously instantiated Noise sessions. Hence, all devices are able to send and receive new messages on the content topic associated to such session.<!-- --></p>
<!-- --><figure class="rehype-figure"><img src="/compiled-assets//img/noise/NM.png" alt=""/></figure>
<!-- --><p>In the <!-- --><span><span style="display:inline">$NM$</span></span> session management scheme, instead, all pairs of Alice&#x27;s and Bob&#x27;s devices have a distinct Noise session: a message is then sent from the currently-in-use senders device to all recipients devices, by properly encrypting and sending it to the content topics of each corresponding Noise session. If sent messages should be available on all senders devices as well, we require each pair of senders devices to instantiate a Noise session used for syncing purposes.<!-- --></p>
<!-- --><p>For more technical details on how Noise sessions are instantiated and managed within these two mechanisms and the different trade-offs provided by the latter, we refer to <!-- --><a href="https://rfc.vac.dev/spec/37/">37/WAKU2-NOISE-SESSIONS<!-- --></a>.<!-- --></p>
<!-- --><h1><a class="anchor" id="conclusions"></a><a class="ha" href="#conclusions">Conclusions<!-- --></a></h1>
<!-- --><p>In this post we provided an overview of Noise, a protocol framework for designing Diffie-Hellman based key-exchange mechanisms allowing systematic security and threat model analysis.<!-- --></p>
<!-- --><p>The flexibility provided by Noise components allows not only to fully replicate with same security guarantees well established key-exchange primitives such as X3DH, currently employed by Status <!-- --><a href="https://specs.status.im/spec/5">5/TRANSPORT-SECURITY<!-- --></a>, but enables also optimizations based on the reciprocal knowledge parties have of each other while allowing easier protocols&#x27; security analysis and (formal) verification.<!-- --></p>
<!-- --><p>Furthermore, different handshakes can be combined and executed one after each other, a particularly useful feature to authenticate multiple static keys employed by different applications but also to ease keys revocation.<!-- --></p>
<!-- --><p>The possibility to manage Noise sessions over multiple devices and the fact that handshakes can be concretely instantiated using modern, fast and secure cryptographic primitives such as <!-- --><a href="https://datatracker.ietf.org/doc/html/rfc7539">ChaChaPoly<!-- --></a> and <!-- --><a href="https://datatracker.ietf.org/doc/html/rfc7693">BLAKE2b<!-- --></a>, make Noise one of the best candidates for efficiently and securely address the many different needs of applications built on top of Waku requiring key-agreement.<!-- --></p>
<!-- --><h2><a class="anchor" id="future-steps"></a><a class="ha" href="#future-steps">Future steps<!-- --></a></h2>
<!-- --><p>The available <!-- --><a href="https://github.com/status-im/nwaku/tree/master/waku/v2/protocol/waku_noise">implementation<!-- --></a> of Noise in <!-- --><code>nwaku</code>, although mostly complete, is still in its testing phase. As future steps we would like to:<!-- --></p>
<!-- --><ul>
<!-- --><li>have an extensively tested and robust Noise implementation;<!-- --></li>
<!-- --><li>formalize, implement and test performances of the two proposed <!-- --><span><span style="display:inline">$N11M$</span></span> and <!-- --><span><span style="display:inline">$NM$</span></span> session management mechanisms and their suitability for common use-case scenarios;<!-- --></li>
<!-- --><li>provide Waku network nodes a native protocol to readily support key-exchanges, strongly-encrypted communication and multi-device session management mechanisms with none-to-little interaction besides applications&#x27; connection requests.<!-- --></li>
<!-- --></ul>
<!-- --><h1><a class="anchor" id="references"></a><a class="ha" href="#references">References<!-- --></a></h1>
<!-- --><ul>
<!-- --><li><a href="https://rfc.vac.dev/spec/6/">6/WAKU1<!-- --></a></li>
<!-- --><li><a href="https://rfc.vac.dev/spec/10/">10/WAKU2<!-- --></a></li>
<!-- --><li><a href="https://rfc.vac.dev/spec/13/">13/WAKU2-STORE<!-- --></a></li>
<!-- --><li><a href="https://rfc.vac.dev/spec/26/">26/WAKU-PAYLOAD<!-- --></a></li>
<!-- --><li><a href="https://rfc.vac.dev/spec/35/">35/WAKU2-NOISE<!-- --></a></li>
<!-- --><li><a href="https://rfc.vac.dev/spec/37/">37/WAKU2-NOISE-SESSIONS<!-- --></a></li>
<!-- --><li><a href="https://specs.status.im/spec/5">5/TRANSPORT-SECURITY<!-- --></a></li>
<!-- --><li><a href="https://github.com/libp2p/specs/tree/master/pubsub">The PubSub/GossipSub Protocols<!-- --></a></li>
<!-- --><li><a href="http://www.noiseprotocol.org/noise.html">The Noise Protocol Framework<!-- --></a></li>
<!-- --><li><a href="https://signal.org/docs/specifications/x3dh/">The X3DH Key-agreement Protocol<!-- --></a></li>
<!-- --><li><a href="https://eprint.iacr.org/2019/1363.pdf">Multi-Device for Signal<!-- --></a></li>
<!-- --><li><a href="https://signal.org/docs/specifications/sesame/">Signals Sesame Algorithm<!-- --></a>.<!-- --></li>
<!-- --><li><a href="https://en.wikipedia.org/wiki/Public-key_cryptography">Public-key cryptography<!-- --></a></li>
<!-- --><li><a href="https://en.wikipedia.org/wiki/Elliptic_curve">Elliptic curves<!-- --></a></li>
<!-- --><li><a href="https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication">Elliptic Curve point multiplication<!-- --></a></li>
<!-- --><li><a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">Symmetric key algorithm<!-- --></a></li>
<!-- --><li><a href="https://en.wikipedia.org/wiki/Authenticated_encryption">Authenticated encryption<!-- --></a></li>
<!-- --><li><a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie-Hellman Key-Exchange<!-- --></a></li>
<!-- --><li><a href="https://en.wikipedia.org/wiki/Discrete_logarithm">The Discrete Logarithm Problem<!-- --></a></li>
<!-- --><li><a href="https://en.wikipedia.org/wiki/Computational_Diffie%E2%80%93Hellman_assumption">Computational Diffie-Hellman Assumption<!-- --></a></li>
<!-- --><li><a href="https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme">The ECIES Encryption Algorithm<!-- --></a></li>
<!-- --><li><a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">The ECDSA Signature Algorithm<!-- --></a></li>
<!-- --><li><a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">The Galois Counter Mode mode of operation<!-- --></a></li>
<!-- --><li><a href="https://datatracker.ietf.org/doc/html/rfc7539">The ChaChaPoly AEAD Cipher<!-- --></a></li>
<!-- --><li><a href="https://datatracker.ietf.org/doc/html/rfc7693">The BLAKE2b Hash Function<!-- --></a></li>
<!-- --><li><a href="https://en.wikipedia.org/wiki/SHA-3">The SHA-3 Hash Function<!-- --></a></li>
<!-- --></ul></article><aside class="Styles_container__3DqFl Style_toc__v7JJe Styles_common_toc__nMHyQ hidden-scroll"><nav class="Styles_tocComponent__fhPld hidden-scroll"><ul><li class="h-1"><a class="" href="/wakuv2-noise#introduction">Introduction</a></li><li class="h-2"><a class="" href="/wakuv2-noise#the-diffie-hellman-key-exchange">The Diffie-Hellman Key-exchange</a></li><li class="h-2"><a class="" href="/wakuv2-noise#ephemeral-and-static-public-keys">Ephemeral and Static Public Keys</a></li><li class="h-1"><a class="" href="/wakuv2-noise#the-noise-protocol-framework">The Noise Protocol Framework</a></li><li class="h-2"><a class="" href="/wakuv2-noise#message-patterns">Message patterns</a></li><li class="h-2"><a class="" href="/wakuv2-noise#the-noise-state-objects">The Noise State Objects</a></li><li class="h-1"><a class="" href="/wakuv2-noise#supported-noise-handshakes-in-waku">Supported Noise Handshakes in Waku</a></li><li class="h-3"><a class="" href="/wakuv2-noise#the-k1k1-handshake">The K1K1 Handshake</a></li><li class="h-3"><a class="" href="/wakuv2-noise#the-xk1-handshake">The XK1 Handshake</a></li><li class="h-3"><a class="" href="/wakuv2-noise#the-xx-and-x-xpsk0-handshakes">The XX and XXpsk0 Handshakes</a></li><li class="h-1"><a class="" href="/wakuv2-noise#session-management-and-multi-device-support">Session Management and Multi-Device Support</a></li><li class="h-1"><a class="" href="/wakuv2-noise#conclusions">Conclusions</a></li><li class="h-2"><a class="" href="/wakuv2-noise#future-steps">Future steps</a></li><li class="h-1"><a class="" href="/wakuv2-noise#references">References</a></li></ul></nav></aside></main><footer class="Styles_container___YkOC undefined Styles_common_footer__1rPoh"><div class="footer-content-container Styles_content__0jn9p"><div><p><span class="copy-left"></span><span>2023<!-- --></span><span> Vac Research</span><span> - </span><span>Vac - Communication, Privacy, Etc</span></p></div><div class="Styles_bottomPart__CsMh_"><div class="Styles_socialMedia__AmAKz "><span><a href="https://twitter.com/vacp2p" class="button"><svg xmlns="http://www.w3.org/2000/svg" width="30" viewBox="0 0 543.684 543.684" xml:space="preserve"><path d="M527.657 106.697a231.362 231.362 0 0 1-8.041 2.191c-16.384 4.137-17.89-1.322-6.028-13.366a109.306 109.306 0 0 0 14.082-17.607c9.137-14.217 1.212-20.417-14.333-13.776a224.853 224.853 0 0 1-16.897 6.432c-16.017 5.379-38.746-2.735-53.018-11.787-18.018-11.426-38.495-17.136-61.438-17.136-32.137 0-59.529 11.334-82.192 33.984-22.656 22.662-33.99 50.062-33.99 82.191 0 4.394.251 8.855.747 13.378.814 7.362-11.585 12.699-28.317 10.336-36.194-5.11-70.582-16.077-103.171-32.889-32.32-16.671-60.845-37.65-85.57-62.938-11.819-12.086-27.804-11.045-32.217 5.27-2.644 9.78-3.959 19.951-3.959 30.515 0 19.908 4.675 38.372 14.027 55.392 4.651 8.47 10.098 16.138 16.353 22.999 10.521 11.549 8.911 18.25-5.734 14.144-14.639-4.106-25.367-10.202-25.367-9.804v.722c0 28.048 8.807 52.693 26.432 73.911 10.857 13.072 23.47 23.17 37.834 30.282 15.147 7.503 22.203 11.688 13.733 12.784-5.11.661-10.251.991-15.422.991-3.5 0-7.172-.159-11.003-.483-6.059-.514-7.148 12.111 2.038 26.298 7.301 11.273 16.646 21.193 28.03 29.762 11.579 8.721 24.058 14.981 37.417 18.794 16.255 4.633 19.517 13.073 5.024 21.763-35.863 21.519-75.551 32.277-119.058 32.277-4.902 0-9.578-.11-14.045-.324-7.754-.373-2.552 6.456 12.417 14.296 46.775 24.499 97.43 36.738 151.972 36.738 41.237 0 79.964-6.529 116.176-19.596 36.199-13.066 67.136-30.576 92.791-52.516 25.655-21.94 47.779-47.173 66.365-75.711 18.581-28.537 32.424-58.33 41.543-89.376 9.106-31.053 13.666-62.167 13.666-93.342 0-2.809-.024-5.331-.067-7.552-.086-4.174 10.955-15.472 23.28-27.032a242.397 242.397 0 0 0 15.937-16.444c11.179-12.688 6.228-18.502-9.997-13.771z"></path></svg></a></span><span><a href="https://discord.gg/PQFdubGt6d" class="button"><svg width="30" viewBox="0 0 71 55" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#discord_svg__a)"><path d="M60.105 4.898A58.55 58.55 0 0 0 45.653.415a.22.22 0 0 0-.233.11 40.784 40.784 0 0 0-1.8 3.697c-5.456-.817-10.886-.817-16.23 0-.485-1.164-1.201-2.587-1.828-3.697a.228.228 0 0 0-.233-.11 58.386 58.386 0 0 0-14.451 4.483.207.207 0 0 0-.095.082C1.578 18.73-.944 32.144.293 45.39a.244.244 0 0 0 .093.167c6.073 4.46 11.955 7.167 17.729 8.962a.23.23 0 0 0 .249-.082 42.08 42.08 0 0 0 3.627-5.9.225.225 0 0 0-.123-.312 38.772 38.772 0 0 1-5.539-2.64.228.228 0 0 1-.022-.378c.372-.279.744-.569 1.1-.862a.22.22 0 0 1 .23-.03c11.619 5.304 24.198 5.304 35.68 0a.219.219 0 0 1 .233.027c.356.293.728.586 1.103.865a.228.228 0 0 1-.02.378 36.384 36.384 0 0 1-5.54 2.637.227.227 0 0 0-.121.315 47.249 47.249 0 0 0 3.624 5.897.225.225 0 0 0 .249.084c5.801-1.794 11.684-4.502 17.757-8.961a.228.228 0 0 0 .092-.164c1.48-15.315-2.48-28.618-10.497-40.412a.18.18 0 0 0-.093-.084Zm-36.38 32.427c-3.497 0-6.38-3.211-6.38-7.156 0-3.944 2.827-7.156 6.38-7.156 3.583 0 6.438 3.24 6.382 7.156 0 3.945-2.827 7.156-6.381 7.156Zm23.593 0c-3.498 0-6.38-3.211-6.38-7.156 0-3.944 2.826-7.156 6.38-7.156 3.582 0 6.437 3.24 6.38 7.156 0 3.945-2.798 7.156-6.38 7.156Z" fill="#23272A"></path></g><defs><clipPath id="discord_svg__a"><path fill="#fff" d="M0 0h71v55H0z"></path></clipPath></defs></svg></a></span><span><a href="https://github.com/vacp2p" class="button"><svg width="30" viewBox="0 0 1024 1024" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M512 0C229.12 0 0 229.12 0 512c0 226.56 146.56 417.92 350.08 485.76 25.6 4.48 35.2-10.88 35.2-24.32 0-12.16-.64-52.48-.64-95.36-128.64 23.68-161.92-31.36-172.16-60.16-5.76-14.72-30.72-60.16-52.48-72.32-17.92-9.6-43.52-33.28-.64-33.92 40.32-.64 69.12 37.12 78.72 52.48 46.08 77.44 119.68 55.68 149.12 42.24 4.48-33.28 17.92-55.68 32.64-68.48-113.92-12.8-232.96-56.96-232.96-252.8 0-55.68 19.84-101.76 52.48-137.6-5.12-12.8-23.04-65.28 5.12-135.68 0 0 42.88-13.44 140.8 52.48 40.96-11.52 84.48-17.28 128-17.28 43.52 0 87.04 5.76 128 17.28 97.92-66.56 140.8-52.48 140.8-52.48 28.16 70.4 10.24 122.88 5.12 135.68 32.64 35.84 52.48 81.28 52.48 137.6 0 196.48-119.68 240-233.6 252.8 18.56 16 34.56 46.72 34.56 94.72 0 68.48-.64 123.52-.64 140.8 0 13.44 9.6 29.44 35.2 24.32C877.44 929.92 1024 737.92 1024 512 1024 229.12 794.88 0 512 0Z" fill="#1B1F23"></path></svg></a></span></div><nav class="Styles_legal__0ciDG"><a title="Privacy Policy" href="/privacy-policy">Privacy Policy</a></nav></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"markdown":{"content":"# Introduction\nIn this post we will provide an overview of how [Waku v2](https://rfc.vac.dev/spec/10/) users can adopt [Noise handshakes](http://www.noiseprotocol.org/noise.html) to agree on cryptographic keys used to securely encrypt messages.\n\nThis process belongs to the class of _key-exchange_ mechanisms, consisting of all those protocols that, with different levels of complexity and security guarantees, allow two parties to publicly agree on a secret without letting anyone else know what this secret is.\n\nBut why do we need key-exchange mechanisms in the first place? \n\nWith the advent of [public-key cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography), it become possible to decouple encryption from decryption through use of two distinct cryptographic keys: one _public_, used to encrypt information and that can be made available to anyone, and one _private_ (kept secret), which enables decryption of messages encrypted with its corresponding public key. The same does not happen in the case of [symmetric encryption schemes](https://en.wikipedia.org/wiki/Symmetric-key_algorithm) where, instead, the same key is used for both encryption and decryption operations and hence cannot be publicly revealed as for public keys.\n\n\nIn order to address specific application needs, many different public, symmetric and hybrid cryptographic schemes were designed: [Waku v1](https://rfc.vac.dev/spec/6/) and [Waku v2](https://rfc.vac.dev/spec/10/), which inherits part of their design from the Ethereum messaging protocol [Whisper](https://ethereum.org/en/developers/docs/networking-layer/#whisper), provide [support](https://rfc.vac.dev/spec/26/) to both public-key primitives ([`ECIES`](https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme), [`ECDSA`](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)) and symmetric primitives ([`AES-256-GCM`](https://en.wikipedia.org/wiki/Galois/Counter_Mode), [`KECCAK-256`](https://en.wikipedia.org/wiki/SHA-3)), used to sign, hash, encrypt and decrypt exchanged messages. \n\nIn principle, when communications employ public-key based encryption schemes (`ECIES`, in the case of Waku), there is no need for a key-agreement among parties: messages can be directly encrypted using the recipient's public-key before being sent over the network. However, public-key encryption and decryption primitives are usually very inefficient in processing large amount of data, and this may constitute a bottleneck for many of today's applications. Symmetric encryption schemes such as `AES-256-GCM`, on the other hand, are much more efficient, but the encryption/decryption key needs to be shared among users beforehand any encrypted messages is exchanged. \n\nTo counter the downsides given by each of these two approaches while taking advantage of their strengths, hybrid constructions were designed. In these, public-key primitives are employed to securely agree on a secret key which, in turn, is used with a symmetric cipher for encrypting messages. In other words, such constructions specify a (public-key based) key-agreement mechanism!\n\nWaku, up to [payload version 1](https://rfc.vac.dev/spec/14/#payload-encryption), does not implement nor recommend any protocol for exchanging symmetric ciphers' keys, leaving such task to the application layer. It is important to note that the kind of key-agreement employed has a direct impact on the security properties that can be granted on later encrypted messages, while security requirements usually depend on the specific application for which encryption is needed in the first place.\n\nIn this regard, [Status](https://status.im), which  builds on top of Waku, [implements](https://specs.status.im/spec/5) a custom version of the [X3DH](https://signal.org/docs/specifications/x3dh/) key-agreement protocol, in order to allow users to instantiate end-to-end encrypted communication channels. However, although such a solution is optimal when applied to (distributed) E2E encrypted chats, it is not flexible enough to fit or simplify the variety of applications Waku aims to address.\nHence, proposing and implementing one or few key-agreements which provide certain (presumably _strong_) security guarantees, would inevitably degrade performances of all those applications for which, given their security requirements, more tailored and efficient key-exchange mechanisms can be employed.\n\n\nGuided by different examples, in the following sections we will overview Noise, a protocol framework we are [currently integrating](https://rfc.vac.dev/spec/35/) in Waku, for building secure key-agreements between two parties. One of the great advantage of using Noise is that it is possible to add support to new key-exchanges by just specifying users' actions from a predefined list, requiring none to minimal modifications to existing implementations. Furthermore, Noise provides a framework to systematically analyze protocols' security properties and the corresponding attacker threat models. This allows not only to easily design new key-agreements eventually optimized for specific applications we want to address, but also to easily analyze or even [formally verify](https://noiseexplorer.com/) any of such custom protocol!\n \nWe believe that with its enormous flexibility and features, Noise represents a perfect candidate for bringing key-exchange mechanisms in Waku.\n\n## The Diffie-Hellman Key-exchange\n\nThe formalization of modern public-key cryptography started with the pioneering work of Whitefield Diffie and Martin Hellman, who detailed one of the earliest known key-agreement protocols: the famous [Diffie-Hellman Key-Exchange](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange).\n\nDiffie-Hellman (DH) key-exchange is largely used today and represents the main cryptographic building block on which Noise handshakes' security is based.\n\nIn turn, the security of DH is based on a mathematical problem called [discrete logarithm](https://en.wikipedia.org/wiki/Discrete_logarithm) which is believed to be hard when the agreement is practically instantiated using certain [elliptic curves](https://en.wikipedia.org/wiki/Elliptic_curve) $E$ defined over finite fields $\\mathbb{F}_p$.\n\nInformally, a DH exchange between Alice and Bob proceeds as follows:\n- Alice picks a secret scalar $s_A\\in\\mathbb{F}_p$ and computes, using the underlying [curve's arithmetic](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication), the point $P_A = s_A\\cdot P\\in E(\\mathbb{F}_p)$ for a certain pre-agreed public generator $P$ of the elliptic curve $E(\\mathbb{F}_p)$. She then sends $P_A$ to Bob.\n- Similarly, Bob picks a secret scalar $s_B\\in\\mathbb{F}_p$, computes $P_B = s_B\\cdot P\\in E(\\mathbb{F}_p)$ and sends $P_B$ to Alice.\n- By commutativity of scalar multiplication, both Alice and Bob can now compute the point $P_{AB} = s_As_B\\cdot P$, using the elliptic curve point received from the other party and their secret scalar.\n\n\nThe assumed hardness of computing discrete logarithms in the elliptic curve, ensures that it is not possible to compute $s_A$ or $s_B$ from $P_A$ and $P_B$, respectively. Another security assumption (named [Computational Diffie-Hellman assumption](https://en.wikipedia.org/wiki/Computational_Diffie%E2%80%93Hellman_assumption)) ensures that it is not possible to compute $P_{AB}$ from $P$, $P_A$ and $P_B$. Hence the point $P_{AB}$ shared by Alice and Bob at the end of the above protocol cannot be efficiently computed by an attacker intercepting $P_A$ and $P_B$, and can then be used to generate a secret to be later employed, for example, as a symmetric encryption key.\n\nOn a side note, this protocol shows the interplay between two components typical to public-key based schemes: the scalars $s_A$ and $s_B$ can be seen as _private keys_ associated to the _public keys_ $P_A$ and $P_B$, respectively, which allow Alice and Bob only to compute the shared secret point $P_{AB}$.\n\n## Ephemeral and Static Public Keys\n\nAlthough we assumed that it is practically impossible for an attacker to compute the randomly picked secret scalar from the corresponding public elliptic curve point, it may happen that such scalar gets compromised or can be guessed due to a faulty employed random number generator. In such cases, an attacker will be able to recover the final shared secret and all encryption keys eventually derived from that, with clear catastrophic consequences for the privacy of exchanged messages.\n\nTo mitigate such issues, multiple DH operations can be combined using two different types of exchanged elliptic curve points or, better, _public keys_: _ephemeral keys_, that is random keys used only once in a DH operation, and long-term _static keys_, used mainly for authentication purposes since employed multiple times.\n\nJust to provide an example, let us suppose Alice and Bob perform the following custom DH-based key-exchange protocol:\n- Alice generates an ephemeral key $E_A=e_A\\cdot P$ by picking a random scalar $e_A$ and sends $E_A$ to Bob;\n- Similarly, Bob generates an ephemeral key $E_B=e_B\\cdot P$ and sends $E_B$ to Alice;\n- Alice and Bob computes $E_{AB} = e_Ae_B \\cdot P$ and from it derive a secret encryption key $k$.\n- Bob sends to Alice his static key $S_B = s_B\\cdot P$ encrypted with $k$.\n- Alice encrypts with $k$ her static key $S_A = s_A\\cdot P$ and sends it to Bob.\n- Alice and Bob decrypt the received static keys, compute the secret $S_{AB} = s_As_B \\cdot P$ and use it together with $E_{AB}$ to derive a new encryption key $\\tilde{k}$ to be later used with a symmetric cipher.\n\nIn this protocol, if Alice's and/or Bob's static keys get compromised, it would not possible to derive the final secret key $\\tilde{k}$, since at least one ephemeral key among $E_A$ and $E_B$ has to be compromised too in order to recover the secret $E_{AB}$. Furthermore, since Alice's and Bob's long-term static keys are encrypted, an attacker intercepting exchanged (encrypted) public keys will not be able to link such communication to Alice or Bob, unless one of the ephemeral key is compromised (and, even in such case, none of the messages encrypted under the key $\\tilde{k}$ can be decrypted).\n\n# The Noise Protocol Framework\n\nIn previous section we gave a small intuition on how multiple DH operations over ephemeral and static users' public keys can be combined to create different key-exchange protocols. \n\nThe [Noise Protocol Framework](http://www.noiseprotocol.org/noise.html), defines various rules for building custom key-exchange protocols while allowing easy analysis of the security properties and threat models provided given the type and order of the DH operations employed.\n\nIn Noise terminology, a key-agreement or _Noise protocol_ consists of one or more _Noise handshakes_. During a Noise handshake, Alice and Bob exchange multiple (handshake) messages containing their ephemeral keys and/or static keys. These public keys are then used to perform a handshake-dependent sequence of Diffie-Hellman operations, whose results are all hashed into a shared secret key. Similarly as we have seen above, after a handshake is complete, each party will use the derived secret key to send and receive [authenticated encrypted data](https://en.wikipedia.org/wiki/Authenticated_encryption) by employing a symmetric cipher.\n\nDepending on the _handshake pattern_ adopted, different security guarantees can be provided on messages encrypted using a handshake-derived key.\n\nThe Noise handshakes we support in Waku all provide the following security properties:\n\n- **Confidentiality**: the adversary should not be able to learn what data is being sent between Alice and Bob.\n- **Strong forward secrecy**: an active adversary cannot decrypt messages nor infer any information on the employed encryption key, even in the case he has access to Alice's and Bob's long-term private keys (during or after their communication).\n- **Authenticity**: the adversary should not be able to cause either Alice or Bob to accept messages coming from a party different than their original senders.\n- **Integrity**: the adversary should not be able to cause Alice or Bob to accept data that has been tampered with.\n- **Identity-hiding**: once a secure communication channel is established, a passive adversary should not be able to link exchanged encrypted messages to their corresponding sender and recipient by knowing their long-term static keys.\n\nWe refer to [Noise specification](http://www.noiseprotocol.org/noise.html) for more formal security definitions and precise threat models relative to Waku [supported Noise Handshake patterns](#Supported-Noise-Handshakes-in-Waku).\n\n## Message patterns\n\nNoise handshakes involving DH operations over ephemeral and static keys can be succinctly sketched using the following set of _handshake message tokens_: `e`,`s`,`ee`,`se`,`es`,`ss`.\n\nTokens employing single letters denote (the type of) users' public keys: `e` refers to randomly generated ephemeral key(s), while `s` indicates the users' long-term static key(s).\n\nTwo letters tokens, instead, denotes DH operations over the two users' public keys the token refers to, given that the left token letter refers to the handshake _initiator's_ public key, while the right token letter indicates the used _responder's_ public key. Thus, if Alice started a handshake with Bob, the `es` token will shortly represent a DH operation among Alice's ephemeral key `e` and Bob's static key `s`.\n\nSince, in order to perform any DH operations users need to share (or pre-share) the corresponding public keys, Noise compactly represents messages' exchanges using the two direction `-\u003e` and `\u003c-`, where the `-\u003e` denotes a message (arbitrary and/or DH public key) from the initiator to the responder, while `\u003c-` the opposite.\n\nHence a _message pattern_ consisting of a direction and one or multiple tokens such as `\u003c- e, s, es`  has to be interpreted one token at a time: in this example, the responder is sending his ephemeral and static key to the initiator and is then executing a DH operation over the initiator's ephemeral key `e` (shared in a previously exchanged message pattern) and his static key `s`. On the other hand, such message indicates also that the initiator received the responder's ephemeral and static keys `e` and `s`, respectively, and performed a DH operation over his ephemeral key and the responder's just received static key `s`. In this way, both parties will be able to derive at the end of each message pattern processed the same shared secret, which is eventually used to update any derived symmetric encryption keys computed so far.\n\nIn some cases, DH public keys employed in a handshake are pre-shared before the handshake itself starts. In order to chronologically separate exchanged keys and DH operations performed before and during a handshake, Noise employs the `...` delimiter. \n\nFor example, the following message patterns\n```\n\u003c- e\n...\n-\u003e e, ee\n```\nindicates that the initiator knew the responder's ephemeral key before he sends his own ephemeral key and executes a DH operation between both parties ephemeral keys (similarly, the responder receives the initiator's ephemeral key and does a `ee` DH operation).\n\n\nAt this point it should be clear how such notation is able to compactly represent a large variety of DH based key-agreements. Nevertheless, we can easily define additional tokens and processing rules in order to address specific applications and security requirements, such as the [`psk`](http://www.noiseprotocol.org/noise.html#handshake-tokens) token used to process arbitrary pre-shared key material. \n\nAs an example of Noise flexibility, the custom protocol we detailed [above](#Ephemeral-and-Static-Public-Keys) can be shortly represented as _(Alice is on the left)_:\n```\n-\u003e e\n\u003c- e, ee, s\n-\u003e s, ss\n```\nwhere after each DH operation an encryption key is derived (along with the secrets computed by all previously executed DH operations) in order to encrypt/decrypt any subsequent sent/received message.\n\nAnother example is given by the possibility to replicate within Noise the well established Signal's [X3DH](https://signal.org/docs/specifications/x3dh/) key-agreement protocols, thus making the latter a general framework to design and study security of many practical and widespread DH-based key-exchange protocols.\n\n## The Noise State Objects\n\nWe mentioned multiple times that parties derive an encryption key each time they perform a DH operation, but how does this work in more details?\n\nNoise defines three _state object_: a _Handshake State_, a _Symmetric State_ and a _Cipher State_, each encapsulated into each other and instantiated during the execution of a handshake.\n\nThe Handshake State object stores the user's and other party's received ephemeral and static keys (if any) and embeds a Symmetric State object.\n\nThe Symmetric State, instead, stores a handshake hash value `h`, iteratively updated with any message read/received and DH secret computed, and a chaining key `ck`, updated using a key derivation function every time a DH secret is computed. This object further embeds a Cipher State.\n\nLastly, the Cipher State stores a symmetric encryption `k` key and a counter `n`  used to encrypt and decrypt messages exchanged during the handshake (not only static keys, but also arbitrary payloads). These key and counter are refreshed every time the chaining key is updated.\n\nWhile processing each handshake's message pattern token, all these objects are updated according to some specific _processing rules_ which employ a combination of public-key primitives, hash and key-derivation functions and symmetric ciphers. It is important to note, however, that at the end of each processed message pattern, the two users will share the same Symmetric and Cipher State embedded in their respective Handshake States.\n\nOnce a handshake is complete, users derive two new Cipher States and can then discard the Handshake State object (and, thus, the embedded Symmetric State and Cipher State objects) \nemployed during the handshake. \n\nThese two Cipher states are used to encrypt and decrypt all outbound and inbound after-handshake messages, respectively, and only to these will be granted the confidentiality, authenticity, integrity and identity-hiding properties we detailed above.\n\nFor more details on processing rules, we refer to [Noise specifications](http://www.noiseprotocol.org/noise.html).\n\n\n# Supported Noise Handshakes in Waku\n\n\nThe Noise handshakes we provided support to in Waku address four typical scenarios occurring when an encrypted communication channel between Alice and Bob is going to be created: \n\n- Alice and Bob know each others' static key.\n- Alice knows Bob's static key;\n- Alice and Bob share no key material and they don't know each others' static key.\n- Alice and Bob share some key material, but they don't know each others' static key.\n\nThe possibility to have handshakes based on the reciprocal knowledge parties have of each other, allows designing Noise handshakes that can quickly reach the desired level of security on exchanged encrypted messages while keeping the number of interactions between Alice and Bob minimum.\n\nNonetheless, due to the pure _token-based_ nature of handshake processing rules, implementations can easily add support to any custom handshake pattern with minor modifications, in case more specific application use-cases need to be addressed.\n\nOn a side note, we already mentioned that identity-hiding properties can be guaranteed against a passive attacker that only reads the communication occurring between Alice and Bob. However, an active attacker who compromised one party's static key and actively interferes with the parties' exchanged messages, may lower the identity-hiding security guarantees provided by some handshake patterns. In our security model we exclude such adversary, but, for completeness, in the following we report a summary of possible de-anonymization attacks that can be performed by such an active attacker.\n\n\nFor more details on supported handshakes and on how these are implemented in Waku, we refer to [35/WAKU2-NOISE](https://rfc.vac.dev/spec/35/) RFC.\n\n\n\n### The K1K1 Handshake\n\nIf Alice and Bob know each others' static key (e.g., these are public or were already exchanged in a previous handshake) , they MAY execute a `K1K1` handshake.  In Noise notation *(Alice is on the left)* this can be sketched as:\n```\n K1K1:\n    -\u003e  s\n    \u003c-  s\n       ...\n    -\u003e  e\n    \u003c-  e, ee, es\n    -\u003e  se\n```\nWe note that here only ephemeral keys are exchanged. This handshake is useful in case Alice needs to instantiate a new separate encrypted communication channel with Bob, e.g. opening multiple parallel connections, file transfers, etc.\n\n**Security considerations on identity-hiding (active attacker)**: no static key is transmitted, but an active attacker impersonating Alice can check candidates for Bob's static key.\n\n### The XK1 Handshake\n\nHere, Alice knows how to initiate a communication with Bob and she knows his public static key: such discovery can be achieved, for example, through a publicly accessible register of users' static keys, smart contracts, or through a previous public/private advertisement of Bob's static key.\n\nA Noise handshake pattern that suits this scenario is `XK1`:\n```\n XK1:\n    \u003c-  s\n       ...\n    -\u003e  e\n    \u003c-  e, ee, es\n    -\u003e  s, se\n```\nWithin this handshake, Alice and Bob reciprocally authenticate their static keys `s` using ephemeral keys `e`. We note that while Bob's static key is assumed to be known to Alice (and hence is not transmitted), Alice's static key is sent to Bob encrypted with a key derived from both parties ephemeral keys and Bob's static key.\n\n**Security considerations on identity-hiding (active attacker)**: Alice's static key is encrypted with forward secrecy to an authenticated party. An active attacker initiating the handshake can check candidates for Bob's static key against recorded/accepted exchanged handshake messages.\n\n\n### The XX and XXpsk0 Handshakes\n\nIf Alice is not aware of any static key belonging to Bob (and neither Bob knows anything about Alice), she can execute an `XX` handshake, where each party tran**X**mits to the other its own static key. \n\nThe handshake goes as follows:\n```\n XX:\n    -\u003e  e\n    \u003c-  e, ee, s, es\n    -\u003e  s, se\n```\nWe note that the main difference with `XK1` is that in second step Bob sends to Alice his own static key encrypted with a key obtained from an ephemeral-ephemeral Diffie-Hellman exchange.\n\n\nThis handshake can be slightly changed in case both Alice and Bob pre-shares some secret `psk` which can be used to strengthen their mutual authentication during the handshake execution. One of the resulting protocol, called `XXpsk0`, goes as follow:\n\n```\n XXpsk0:\n    -\u003e  psk, e\n    \u003c-  e, ee, s, es\n    -\u003e  s, se\n```\nThe main difference with `XX` is that Alice's and Bob's static keys, when transmitted, would be encrypted with a key derived from `psk` as well.\n\n\n**Security considerations on identity-hiding (active attacker)**: Alice's static key is encrypted with forward secrecy to an authenticated party for both `XX` and `XXpsk0` handshakes. In `XX`, Bob's static key is encrypted with forward secrecy but is transmitted to a non-authenticated user which can then be an active attacker. In `XXpsk0`, instead, Bob's secret key is protected by forward secrecy to a partially authenticated party (through the pre-shared secret `psk` but not through any static key), provided that `psk` was not previously compromised (in such case identity-hiding properties provided by the `XX` handshake applies).\n\n# Session Management and Multi-Device Support\n\nWhen two users complete a Noise handshake, an encryption/decryption session - or _Noise session_ - consisting of two Cipher States is instantiated.\n\nBy identifying Noise session with a `session-id` derived from the handshake's cryptographic material, we can take advantage of the [PubSub/GossipSub](https://github.com/libp2p/specs/tree/master/pubsub) protocols used by Waku for relaying messages in order to manage instantiated Noise sessions.\n\nThe core idea is to exchange after-handshake messages  (encrypted with a Cipher State specific to the Noise session), over a content topic derived from the (secret) `session-id` the corresponding session refers to.\n\nThis allows to decouple the handshaking phase from the actual encrypted communication, thus improving users' identity-hiding capabilities. \n\nFurthermore, by publicly revealing a value derived from `session-id` on the corresponding session content topic, a Noise session can be marked as _stale_, enabling peers to save resources by discarding any eventually [stored](https://rfc.vac.dev/spec/13/) message sent to such content topic.\n\nOne relevant aspect in today's applications is the possibility for users to employ different devices in their communications. In some cases, this is non-trivial to achieve since, for example, encrypted messages might be required to be synced on different devices which do not necessarily share the necessary key material for  decryption and may be temporarily offline.\n\nWe address this by requiring each user's device to instantiate multiple Noise sessions either with all user's other devices which, in turn, all together share a Noise session with the other party, or by directly instantiating a Noise session with all other party's devices. \n\nWe named these two approaches $N11M$ and $NM$, respectively, which are in turn loosely based on the paper [Multi-Device for Signal](https://eprint.iacr.org/2019/1363.pdf) and [Signals Sesame Algorithm](https://signal.org/docs/specifications/sesame/).\n\n\n![](//img/noise/N11M.png)\n\n\nInformally, in the $N11M$ session management scheme, once the first Noise session between any of Alices and Bobs device is instantiated, its session information is securely propagated to all other devices using previously instantiated Noise sessions. Hence, all devices are able to send and receive new messages on the content topic associated to such session. \n\n![](//img/noise/NM.png)\n\nIn the $NM$ session management scheme, instead, all pairs of Alice's and Bob's devices have a distinct Noise session: a message is then sent from the currently-in-use senders device to all recipients devices, by properly encrypting and sending it to the content topics of each corresponding Noise session. If sent messages should be available on all senders devices as well, we require each pair of senders devices to instantiate a Noise session used for syncing purposes.\n\nFor more technical details on how Noise sessions are instantiated and managed within these two mechanisms and the different trade-offs provided by the latter, we refer to [37/WAKU2-NOISE-SESSIONS](https://rfc.vac.dev/spec/37/).\n\n# Conclusions\n\nIn this post we provided an overview of Noise, a protocol framework for designing Diffie-Hellman based key-exchange mechanisms allowing systematic security and threat model analysis.\n\nThe flexibility provided by Noise components allows not only to fully replicate with same security guarantees well established key-exchange primitives such as X3DH, currently employed by Status [5/TRANSPORT-SECURITY](https://specs.status.im/spec/5), but enables also optimizations based on the reciprocal knowledge parties have of each other while allowing easier protocols' security analysis and (formal) verification.\n\nFurthermore, different handshakes can be combined and executed one after each other, a particularly useful feature to authenticate multiple static keys employed by different applications but also to ease keys revocation.\n\nThe possibility to manage Noise sessions over multiple devices and the fact that handshakes can be concretely instantiated using modern, fast and secure cryptographic primitives such as [ChaChaPoly](https://datatracker.ietf.org/doc/html/rfc7539) and [BLAKE2b](https://datatracker.ietf.org/doc/html/rfc7693), make Noise one of the best candidates for efficiently and securely address the many different needs of applications built on top of Waku requiring key-agreement.\n\n## Future steps\n\nThe available [implementation](https://github.com/status-im/nwaku/tree/master/waku/v2/protocol/waku_noise) of Noise in `nwaku`, although mostly complete, is still in its testing phase. As future steps we would like to:\n- have an extensively tested and robust Noise implementation;\n- formalize, implement and test performances of the two proposed $N11M$ and $NM$ session management mechanisms and their suitability for common use-case scenarios;\n- provide Waku network nodes a native protocol to readily support key-exchanges, strongly-encrypted communication and multi-device session management mechanisms with none-to-little interaction besides applications' connection requests.\n \n# References\n\n- [6/WAKU1](https://rfc.vac.dev/spec/6/)\n- [10/WAKU2](https://rfc.vac.dev/spec/10/) \n- [13/WAKU2-STORE](https://rfc.vac.dev/spec/13/)\n- [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/)\n- [35/WAKU2-NOISE](https://rfc.vac.dev/spec/35/)\n- [37/WAKU2-NOISE-SESSIONS](https://rfc.vac.dev/spec/37/)\n- [5/TRANSPORT-SECURITY](https://specs.status.im/spec/5)\n- [The PubSub/GossipSub Protocols](https://github.com/libp2p/specs/tree/master/pubsub)\n- [The Noise Protocol Framework](http://www.noiseprotocol.org/noise.html)\n- [The X3DH Key-agreement Protocol](https://signal.org/docs/specifications/x3dh/)\n- [Multi-Device for Signal](https://eprint.iacr.org/2019/1363.pdf)\n- [Signals Sesame Algorithm](https://signal.org/docs/specifications/sesame/).\n- [Public-key cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography)\n- [Elliptic curves](https://en.wikipedia.org/wiki/Elliptic_curve)\n- [Elliptic Curve point multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication)\n- [Symmetric key algorithm](https://en.wikipedia.org/wiki/Symmetric-key_algorithm)\n- [Authenticated encryption](https://en.wikipedia.org/wiki/Authenticated_encryption)\n- [Diffie-Hellman Key-Exchange](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)\n- [The Discrete Logarithm Problem](https://en.wikipedia.org/wiki/Discrete_logarithm)\n- [Computational Diffie-Hellman Assumption](https://en.wikipedia.org/wiki/Computational_Diffie%E2%80%93Hellman_assumption)\n- [The ECIES Encryption Algorithm](https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme)\n- [The ECDSA Signature Algorithm](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) \n- [The Galois Counter Mode mode of operation](https://en.wikipedia.org/wiki/Galois/Counter_Mode) \n- [The ChaChaPoly AEAD Cipher](https://datatracker.ietf.org/doc/html/rfc7539)\n- [The BLAKE2b Hash Function](https://datatracker.ietf.org/doc/html/rfc7693)\n- [The SHA-3 Hash Function](https://en.wikipedia.org/wiki/SHA-3)","metadata":{"layout":"post","name":"Noise handshakes as key-exchange mechanism for Waku","title":"Noise handshakes as key-exchange mechanism for Waku","date":"2022-05-17T10:00:00.000Z","author":"s1fr0","published":true,"permalink":"/wakuv2-noise","categories":"research","summary":"We provide an overview of the Noise Protocol Framework as a tool to design efficient and secure key-exchange mechanisms in Waku2.","image":"/img/noise/NM.png","discuss":"https://forum.vac.dev/t/discussion-noise-handshakes-as-key-exchange-mechanism-for-waku/137","_includes":["math"]},"toc":[{"content":"Introduction","slug":"introduction","lvl":1,"i":0,"seen":0},{"content":"The Diffie-Hellman Key-exchange","slug":"the-diffie-hellman-key-exchange","lvl":2,"i":1,"seen":0},{"content":"Ephemeral and Static Public Keys","slug":"ephemeral-and-static-public-keys","lvl":2,"i":2,"seen":0},{"content":"The Noise Protocol Framework","slug":"the-noise-protocol-framework","lvl":1,"i":3,"seen":0},{"content":"Message patterns","slug":"message-patterns","lvl":2,"i":4,"seen":0},{"content":"The Noise State Objects","slug":"the-noise-state-objects","lvl":2,"i":5,"seen":0},{"content":"Supported Noise Handshakes in Waku","slug":"supported-noise-handshakes-in-waku","lvl":1,"i":6,"seen":0},{"content":"The K1K1 Handshake","slug":"the-k1k1-handshake","lvl":3,"i":7,"seen":0},{"content":"The XK1 Handshake","slug":"the-xk1-handshake","lvl":3,"i":8,"seen":0},{"content":"The XX and XXpsk0 Handshakes","slug":"the-xx-and-x-xpsk0-handshakes","lvl":3,"i":9,"seen":0},{"content":"Session Management and Multi-Device Support","slug":"session-management-and-multi-device-support","lvl":1,"i":10,"seen":0},{"content":"Conclusions","slug":"conclusions","lvl":1,"i":11,"seen":0},{"content":"Future steps","slug":"future-steps","lvl":2,"i":12,"seen":0},{"content":"References","slug":"references","lvl":1,"i":13,"seen":0}]},"navProps":{"metadata":{"published":true,"title":"Noise handshakes as key-exchange mechanism for Waku","layout":"post","name":"Noise handshakes as key-exchange mechanism for Waku","date":"2022-05-17T10:00:00.000Z","author":"s1fr0","permalink":"/wakuv2-noise","categories":"research","summary":"We provide an overview of the Noise Protocol Framework as a tool to design efficient and secure key-exchange mechanisms in Waku2.","image":"img/noise/NM.png","discuss":"https://forum.vac.dev/t/discussion-noise-handshakes-as-key-exchange-mechanism-for-waku/137","_includes":["math"]},"navOrder":1652781600,"localPath":"research/2022-05-17-noise.md","path":["wakuv2-noise"],"children":[],"isDir":false},"routeParams":{"path":["wakuv2-noise"]}},"__N_SSG":true},"page":"/[[...path]]","query":{"path":["wakuv2-noise"]},"buildId":"-5vfLOflCSkQPJRugO7ZO","isFallback":false,"dynamicIds":[9440],"gsp":true,"scriptLoader":[]}</script></body></html>