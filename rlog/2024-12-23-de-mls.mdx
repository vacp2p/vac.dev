---
title: 'De-MLS with Waku'
date: 2024-12-23 19:00:00
authors: seemenkina
published: true
slug: de-mls-with-waku
categories: 

toc_min_heading_level: 2
toc_max_heading_level: 4
---

## Introduction

Secure Group Messaging (SGM) is resource-intensive when aiming for robust security features like forward secrecy (FS) and post-compromise security (PCS). 

One straightforward approach to SGM is a pairwise group chat, where each pair of group members establishes a unique encryption key using Diffie-Hellman. While this method ensures security, it falls short in terms of practicality:

- **High storage requirements**: Each participant must store encryption keys for every other participant.
- **Inefficient encryption**: Each message must be encrypted separately for every participant, leading to significant computational overhead.
- **Cumbersome group management**: Adding or removing users and refreshing keys becomes increasingly inefficient as the group grows.

One scalable solution for SGM is Message Layer Security (MLS). Leveraging TreeKEM, MLS organizes group members in a cryptographic tree structure, where each participant is responsible for maintaining specific parts of the tree.

In this post, we present the implementation details of the first version **de-MLS** which is an SGM protocol that satisfies the following features:

- Decentralized
- Scalable
- End-to-end encrypted (E2EE) 
- FS and PCS provided
- Ethereum authenticated 

## Background

### MLS

The Message Layer Security (MLS) protocol offers scalable and secure group messaging protocol by organizing participants into a cryptographic tree structure, enabling efficient operations like adding or removing members with logarithmic time complexity relative to the group size. MLS provides strong security guarantees, including FS and PCS. 

MLS assumes that we have the two services are provided:

   *  An Authentication Service (AS): It enables group members to
      authenticate the credentials presented by other group members.

   *  A Delivery Service (DS) that routes MLS messages among the
      participants in the protocol in the correct order and manage the keyPackage of the users where the keyPackage is the object in MLS that each user can securely generate the latest state of keys in the group.  
      
Despite its scalability, MLS has a notable limitation: it is inherently designed for server-based federated architectures for delivery service (DS), even when the servers themselves don't need to be trusted. To achieve a decentralized protocol, the functionality of DS must be reimagined to eliminate reliance on a central server while preserving the protocol's security properties. Thus, we proposed decentralized MLS (de-MLS), leveraging Waku nodes as peer-to-peer communication protocols to eliminate reliance on centralized servers.

Lastly, MLS operates on an epoch-based model, where group state changes (e.g., adding/removing users or key refreshes) occur between epochs that are always required to be conducted by a single entity. For example, if a user is removed in epoch `E`, the rest of the group members generate a new key in epoch `E + 1` by passing the new entropy. The removed user cannot decrypt messages sent after epoch `E + 1`.

### Waku

Waku is a peer-to-peer communication network. Waku enables private, secure, censorship-free communication by removing the centralized third parties. As a messaging layer, Waku is built on the gosipsub protocol that users join groups by subscribing to specific pub-sub topics. These topics determine the scope and type of messages exchanged, enabling flexible communication patterns.

## de-MLS 

de-MLS is a peer-to-peer SGM protocol that can be used with any P2P messaging application for the DS while we choose Waku as a messaging protocol. The decentralization is not only achieved at the DS level but also at the authentication service (AS) level. We use the special nodes as an authorized identity that authenticate the user before they join the group and remove them. 

de-MLS offers two distinct user management configurations both use Waku protocol as DS:

1. **Single Admin Over a Single Waku Node**: 
   - A single authorized identity (admin) manages the group including removing or adding users.
   
2. **Multi-Admin Over Multiple Waku Nodes**: 
   - Multiple admins have equal authority to add or remove users.
   - A consensus mechanism ensures consistency in handling concurrent changes in the same epoch against the division. 

In multi-admin settings, de-MLS requires a consensus among admins since changes in an epoch in MLS are required to be conducted by a single identity, that is the admin. 

For the consensus integration, ongoing research explores two promising approaches:

1. **Smart contracts**: Outsourcing consensus to a blockchain-based solution for transparent and immutable agreement.
2. **Off-chain consensus mechanisms**: Utilizing off-chain consensus protocol to design efficient, decentralized protocols.

### Waku Integration

The main challenge in moving to a decentralized system was converting the centralized DS to the decentralized DS; which has two key functions.

1. Sending out messages, which includes not only sending to the correct user but also deciding on the correct sequence (docs reference here). 
2. Manages the key package of users. 

Since we can't store the necessary key packages in one place, so users have to provide them on request, and we have to validate them.

One of the first ideas was to use a smart contract (SC) instead of server-side from the package manager's point of view. But this was not the right idea because, as we know, anything that gets into the blockchain cannot be deleted without a trace, and one of the requirements is that each package must be used once and then deleted. 

### Distribution of the Messages

Since the Waku is based on gossipsub protocol and accordingly from the network point of view joining a group for a user will look like subscribing to the necessary topics.

We have pub-sub topics that send messages in the network. We also have content topics, which determine the groups and what messages are sent.

There are three types of topics: 
- `app_msg`: The owner of the topic where messages encrypted with the group key are sent, thanks to encryption, even if someone not from the group subscribes to the topic, they will not be able to read the correspondence itself.
- `commit_msg`: All messages related to changes in the group state - adding users, deleting users, key rotation - are sent here. By design only administrators can send messages about the deletion and addition of users, key update is still under development. At this stage proposal and commit messages are not differentiated and all are considered commit messages
-  `welcome`: A special topic for joining the group. With it, we solve the problem of how users can join a group without the server side. 

This architecture does not have a 1-1 channel with the admin to request to join, the situation is not excluded in that the admin can personally request a package and add a member to the group himself.

### Managing the Key Packages

The main idea is that users provide key packages themselves when joining a group. For this, we use the welcome topic.


How the welcome topic works:
- When a group is created, the admin/admins start posting a special public key with a signature with a set frequency (once per epoch). New users are initially subscribed only to this content topic and upon receiving this message they encrypt their key package with this key.
- At the end of the epoch the administrator prepares a commit message with all new users (in case he wants them to join the group) publishes it in the commit channel, and publishes a welcome message to all new users in the current channel.
- If this process is successful, all new users are subscribed to all other topics and have a group key.  
- Admin does not store key packages longer than one epoch
- If a user fails to send a message to the current epoch, his message is rejected and he has to get the key again and repeat the whole procedure.

The current version so far assumes only one administrator - this is because we need to have a consensus between several users in terms of which commits to accept and which to reject and in what order. 

## Architecture notes

The architecture itself is based on actors, which allows us to focus on the processing of messages rather than on how they will be passed between different entities.

the following actors are implemented
- waku actor - responsible for generating and sending messages to waku, subscribing and unsubscribing to threads (receiving messages from waku is implemented as a constant receiving of events from the node and their processing by sending them to other actors).
- user actor - Manages user-related functionalities, including user creation, group management, and message handling.
- group actor - Handles group-related operations, including group creation, membership management, and message broadcasting.

That in terms of keys, cryptography, etc. 

You can see 3 types of keys.

- Ethereum key: Used for authentication of the user with his private key and the ID is actually the wallet of the user. In fact, this step can be replaced by any web3 service that allows authorization. 
- OpenMLS keys: Used for the reference implementation of de-MLS based on OpenMLS, which provides all necessary API to work with MLS, as well as creating and storing key packages. One of the ideas was to use Ethereum accounts to allocate all necessary keys for groups, but unfortunately, now OpenMLS does not support Ethereum curve operations, so we link these keys not through allocation, but through specification in the identity wallet.
- Admin keys: Used for constantly rotating key which is used in the welcome top to receive key packages from the user

## Benchmark

One of the main advantages of the MLS protocol is that It does not require to exchange of messages in pairs between all participants and decentralization allows us to send only two messages to the group when new participants join which are a commit message and a welcome message. 

In contrast to this advantage, the bottlenecks of the protocol are: 

- First, the admin/admins need to receive a key package from each member who wants to join the group. This action involves sequential message exchange, as well as encryption, decryption, and signatures.
- Secondly adding a member to a group requires rebuilding the tree and computing new keys.  

Even when we say that we are joining a bunch of users, we are in fact sequentially updating the tree and sending the last commit to the existing members of the group,  as well as one welcome message to the new members.

The following measurements were made:

1. We measured how long it takes to process the entire chain of receiving a user key package (which includes generating the admin key, generating messages with signatures and encryption, as well as processing these messages).
It's worth noting that this does not include message forwarding time.

`Share Key Package - 1.8395 ms`

2. And how long does it take to create a commit and welcome message from a ready-made key package bunch 

```
Add 10 users to group - 1.8662 ms 
Add 100 users to group - 14.124 ms
Add 500 users to group - 121.85 ms
Add 1000 users to group - 412.39 ms
Add 5000 users to group ~ 15-20 s
Add 10000 users to group ~ 1-1,5 min
```
All measurements were performed on a laptop on Apple M3 Pro @ 4.05GHz and 12-Core CPU/18-Core GPU. 

Here we also do not take into account network time as well as user application of received commits. 
We plan to implement these measurements in future work.  

## Conclusion

So let's summarize how we end up solving DS tasks with Waku: 

- Sending messages from the server to clients is replaced with publishing/subscribing to pub-sub topics.
- Determining how to apply to commit messages is replaced with introducing administrators, and how consensus will be reached is under development.
- Storage and distribution of key packages by server is replaced by moving to the idea that users provide packages themselves when joining a group + openmls has validation that a package has already been used once for a particular group 

## Future Work

In the next iterations, we plan to implement the following:

- Multi-admin over multiple Waku nodes
- Consensus mechanism for handling concurrent changes within the same epoch
- Off-chain consensus mechanisms
- Key rotation
- Benchmarking for the multi-admin case and over the network

## References

- [1] RFC 9420: The Messaging Layer Security (MLS) Protocol. Retrieved from https://datatracker.ietf.org/doc/rfc9420/
- [2] OpenMLS. Retrived from https://github.com/openmls/openmls
- [3] Waku. Retrived from https://waku.org/
- [4] de-MLS. Retrived from https://github.com/vacp2p/de-mls/
