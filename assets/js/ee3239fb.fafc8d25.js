"use strict";(self.webpackChunkvac_dev=self.webpackChunkvac_dev||[]).push([[6154],{13992:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/nim-gdb-fd0493d2f83bf5f19eb4476e41036b35.png"},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(96540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},49341:e=>{e.exports=JSON.parse('{"permalink":"/rlog/nim-in-logos-01","source":"@site/rlog/2025-07-29-nim-in-logos-edition-1.mdx","title":"Nim in Logos - 1st Edition","description":"Welcome to the first edition of Nim in Logos \u2014 a newsletter covering major Nim features from Logos\' perspective.","date":"2025-07-04T23:00:00.000Z","tags":[],"readingTime":6.06,"hasTruncateMarker":false,"authors":[{"name":"Ivan","github":"ivansete-status","key":"ivansete","page":null},{"name":"Gabriel","github":"gabrielmer","key":"gabrielmer","page":null}],"frontMatter":{"title":"Nim in Logos - 1st Edition","date":"2025-07-04T23:00:00.000Z","authors":["ivansete","gabrielmer"],"published":true,"slug":"nim-in-logos-01","categories":"nim","toc_min_heading_level":2,"toc_max_heading_level":4},"unlisted":false,"prevItem":{"title":"Zerokit optimizations: A performance journey","permalink":"/rlog/2025-zerokit-perf"},"nextItem":{"title":"The MDSECheck method: choosing secure square MDS matrices for P-SP-networks","permalink":"/rlog/mdsecheck-method"}}')},60260:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var s=i(49341),t=i(74848),r=i(28453);const o={title:"Nim in Logos - 1st Edition",date:new Date("2025-07-04T23:00:00.000Z"),authors:["ivansete","gabrielmer"],published:!0,slug:"nim-in-logos-01",categories:"nim",toc_min_heading_level:2,toc_max_heading_level:4},a=void 0,l={authorsImageUrls:[void 0,void 0]},c=[{value:"Nim 2.2  \u2013 Better Stability, Smarter Memory, and Smoother Development",id:"nim-22---better-stability-smarter-memory-and-smoother-development",level:2},{value:"Error Handling in Nim: Why Results Beat Exceptions",id:"error-handling-in-nim-why-results-beat-exceptions",level:2},{value:"The Exception Problem",id:"the-exception-problem",level:4},{value:"The Result Advantage",id:"the-result-advantage",level:4},{value:"Best Practices for Result-Based Error Handling",id:"best-practices-for-result-based-error-handling",level:4},{value:"When to Break the Rules",id:"when-to-break-the-rules",level:4},{value:"Debugging in Nim",id:"debugging-in-nim",level:2},{value:"GDB",id:"gdb",level:4},{value:"Logs - Chronicles",id:"logs---chronicles",level:4},{value:"Logs - echo",id:"logs---echo",level:4},{value:"Heaptrack",id:"heaptrack",level:4},{value:"Formatting code in Nim",id:"formatting-code-in-nim",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Welcome to the first edition of ",(0,t.jsx)(n.strong,{children:"Nim in Logos"})," \u2014 a newsletter covering major Nim features from Logos' perspective."]}),"\n",(0,t.jsxs)(n.p,{children:["If you have comments or suggestions, feel free to reach out to the authors directly or start a thread in the ",(0,t.jsx)(n.a,{href:"https://discord.gg/logosnetwork",children:"Logos Discord server"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"nim-22---better-stability-smarter-memory-and-smoother-development",children:"Nim 2.2  \u2013 Better Stability, Smarter Memory, and Smoother Development"}),"\n",(0,t.jsx)(n.p,{children:"The Nim 2.2 release series focuses on improving language stability, fixing long-standing bugs, and optimizing performance\u2014particularly in the ORC memory management system. The latest patch in this series, version 2.2.4, continues to build on these goals."}),"\n",(0,t.jsx)(n.p,{children:"Here are some of the key highlights from the 2.2 series:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"More powerful generics and type expressions:"})," Stabilization of generics, typedesc, and static types. These features now support arbitrary expressions that previously only worked in limited cases, making them more reliable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Improved tuple unpacking:"})," Tuple unpacking now supports discarding values using underscores (_) and allows inline type annotations for unpacked elements."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory leak fixes:"})," Issues with memory leaks when using std/nre\u2019s regular expressions or nested exceptions have been resolved."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"More efficient async code:"})," Futures no longer always copy data, resulting in better performance in asynchronous workflows."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"String bug fixes:"})," Several issues involving string and cstring usage have been corrected."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In addition to core language improvements:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"NimSuggest stability:"})," The language server has received multiple fixes, improving the experience in IDEs and editors that rely on NimSuggest for autocompletion and error checking."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Better code generation:"})," Numerous issues related to invalid or broken C and C++ code generation and backend-specific bugs have been addressed, improving Nim\u2019s reliability when targeting other languages."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["You can read the full release announcement and changelog ",(0,t.jsx)(n.a,{href:"https://nim-lang.org/blog/2024/10/02/nim-220-2010.html",children:"here"})]}),"\n",(0,t.jsx)(n.h2,{id:"error-handling-in-nim-why-results-beat-exceptions",children:"Error Handling in Nim: Why Results Beat Exceptions"}),"\n",(0,t.jsx)(n.p,{children:"Error handling is one of the most critical aspects of writing reliable software, yet it remains a contentious topic in many programming languages. In Nim, developers face a unique challenge: multiple error handling paradigms are supported, leading to confusion about which approach to choose. For robust, maintainable code, our answer at Logos is increasingly clear\u2014favor Result types over exceptions."}),"\n",(0,t.jsx)(n.h4,{id:"the-exception-problem",children:"The Exception Problem"}),"\n",(0,t.jsx)(n.p,{children:"While exceptions might seem convenient for quick scripts and prototypes, they introduce significant challenges in complex, long-running applications:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Silent API Changes"}),": One of the most dangerous aspects of exception-based error handling is that changes deep within dependencies can break your code without any compile-time warning. When a function suddenly starts throwing a new exception type, your code may fail at runtime under exceptional circumstances\u2014often when you least expect it."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource Management Issues"}),": Exceptions create unpredictable control flow that can lead to resource leaks, security vulnerabilities, and unexpected crashes. When an exception unwinds the stack, resources may not be properly cleaned up."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Refactoring Difficulties"}),": The compiler provides little assistance when working with exception-based code. Adding a new exception type breaks the ABI but leaves the API unchanged, making it nearly impossible to track down all the places that need updating."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"the-result-advantage",children:"The Result Advantage"}),"\n",(0,t.jsx)(n.p,{children:"The Result type offers a compelling alternative that makes error handling explicit, predictable, and compiler-verified:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# Enforce that no exceptions can\'t be raised in this module\n{.push raises: [].}\n\nimport results\n\nproc doSomething(): Result[void, string] =\n# Implementation here\n\nproc getRandomInt(): Result[int, string] =\n# Implementation here\n\ndoSomething().isOkOr:\n\necho "Failed doing something, error: ", & error\n\nrandomInt = getRandomInt().valueOr:\n\necho "Failed getting random int, error: ", & error\n'})}),"\n",(0,t.jsx)(n.p,{children:"Notice that this usage of Result is much more concise and easier to follow than try-except blocks"}),"\n",(0,t.jsx)(n.h4,{id:"best-practices-for-result-based-error-handling",children:"Best Practices for Result-Based Error Handling"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Make Errors Explicit"}),": Use Result when multiple failure paths exist and calling code needs to differentiate between them. This makes error handling visible at the call site and forces developers to consciously handle failure cases."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handle Errors Locally"}),": Address errors at each abstraction level rather than letting them bubble up through multiple layers. This prevents spurious abstraction leakage and keeps error handling logic close to where problems occur."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Exception Tracking"}),": Enable exception tracking with ",(0,t.jsx)(n.code,{children:"{.push raises: [].}"})," at the module level. This helps identify any remaining exception-throwing code and ensures new code follows the Result pattern."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"when-to-break-the-rules",children:"When to Break the Rules"}),"\n",(0,t.jsx)(n.p,{children:"While Result should be your default choice, exceptions still have their place:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Assertions and Logic Errors"}),": Use assertions for violated preconditions or situations where recovery isn't possible or expected."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Legacy Integration"}),": When interfacing with exception-heavy libraries, you may need to use exceptions at integration boundaries, but convert them to Result types as quickly as possible. To ensure safe exception handling, explicitly declare which exceptions a procedure may raise using the ",(0,t.jsx)(n.code,{children:"{.raises: [SpecificException].}"})," pragma."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Error handling in Nim continues to evolve, but the trend is clear: explicit error handling through Result types provides better safety, maintainability, and debugging experience than exceptions. By making errors part of your function signatures and forcing explicit handling at call sites, you create more robust software that fails gracefully and predictably."}),"\n",(0,t.jsx)(n.h2,{id:"debugging-in-nim",children:"Debugging in Nim"}),"\n",(0,t.jsx)(n.p,{children:"Nowadays, analyzing the behavior of a Nim program is not as straightforward as debugging a C++ application, for example."}),"\n",(0,t.jsx)(n.h4,{id:"gdb",children:"GDB"}),"\n",(0,t.jsx)(n.p,{children:"GDB can be used, and step-by-step debugging with GDB and VSCode is possible. However, the interaction is not very smooth. You can set breakpoints in VSCode and press F5 to run the program up to the breakpoint and continue debugging from there. That said, the state of variables is not fully demangled. For example:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"img",src:i(13992).A+"",width:"471",height:"497"})}),"\n",(0,t.jsx)(n.p,{children:"For that reason, GDB is not the preferred option in Logos"}),"\n",(0,t.jsx)(n.h4,{id:"logs---chronicles",children:"Logs - Chronicles"}),"\n",(0,t.jsxs)(n.p,{children:["At Logos, we primarily debug Nim applications using log outputs. In particular, we make extensive use of the ",(0,t.jsx)(n.a,{href:"https://github.com/status-im/nim-chronicles",children:"nim-chronicles"})," library."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"nim-chronicles"})," is a robust logging library that automatically includes the following contextual information in each log entry:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Calling thread ID"}),"\n",(0,t.jsx)(n.li,{children:"Current timestamp"}),"\n",(0,t.jsx)(n.li,{children:"Log level (e.g., TRACE, DEBUG, INFO, WARN, ERROR, FATAL)"}),"\n",(0,t.jsx)(n.li,{children:"Source file name"}),"\n",(0,t.jsx)(n.li,{children:"Line number of the log statement"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, ",(0,t.jsx)(n.code,{children:"chronicles"})," supports attaching custom log messages along with relevant variable values, which proves especially useful for debugging. For instance, in the following example, the log message is ",(0,t.jsx)(n.code,{children:'"Configuration. Shards"'}),", and it includes the value of an additional variable, ",(0,t.jsx)(n.code,{children:"shard"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'INF 2025-07-01 09:56:57.705+02:00 Configuration. Shards                      topics="waku conf" tid=28817 file=waku_conf.nim:147 shard=64\n'})}),"\n",(0,t.jsx)(n.p,{children:"There are also useful techniques for displaying more detailed information about specific variables:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"repr(p)"})," \u2014 Returns a string representation of the variable ",(0,t.jsx)(n.code,{children:"p"}),", providing a more comprehensive view of its contents."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"name(typeof(p))"})," \u2014 Extracts the type of the variable ",(0,t.jsx)(n.code,{children:"p"})," as a string. This is particularly helpful when working with pointers or generics."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"logs---echo",children:"Logs - echo"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://nim-lang.org/docs/system.html#echo%2Cvarargs%5Btyped%2C%5D",children:"echo"})," statement in Nim serves as a basic debugging tool, although it is less powerful and flexible compared to ",(0,t.jsx)(n.code,{children:"nim-chronicles"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Besides, ",(0,t.jsx)(n.a,{href:"https://www.notion.so/Nim-in-Logos-July-2025-2038f96fb65c8042bcbbe676ee8f2182?pvs=21",children:"debugEcho"})," is an interesting alternative, which behaves similarly to ",(0,t.jsx)(n.code,{children:"echo"})," but it allows working on routines marked with no side effects."]}),"\n",(0,t.jsx)(n.h4,{id:"heaptrack",children:"Heaptrack"}),"\n",(0,t.jsx)(n.p,{children:"This technique enables precise insight into where memory is being consumed within a Nim application."}),"\n",(0,t.jsxs)(n.p,{children:["It is particularly useful for identifying potential memory leaks and is widely employed in ",(0,t.jsx)(n.strong,{children:"nwaku"})," (Nim Waku). For more details, refer to the documentation: ",(0,t.jsx)(n.a,{href:"https://github.com/waku-org/nwaku/blob/master/docs/tutorial/heaptrack.md",children:"Heaptrack Tutorial"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"formatting-code-in-nim",children:"Formatting code in Nim"}),"\n",(0,t.jsx)(n.p,{children:"Maintaining a consistent code format is essential for readability and for facilitating clear diff comparisons during code reviews."}),"\n",(0,t.jsxs)(n.p,{children:["To support this, Logos strongly recommends using ",(0,t.jsx)(n.a,{href:"https://arnetheduck.github.io/nph/",children:(0,t.jsx)(n.em,{children:"nph"})})," across all Nim projects."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);