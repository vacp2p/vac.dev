"use strict";(self.webpackChunkvac_dev=self.webpackChunkvac_dev||[]).push([[2594],{32788:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>h});var n=r(87462),a=(r(67294),r(3905));const o={layout:"post",name:"DNS Based Discovery",title:"DNS Based Discovery",date:new Date("2020-02-07T12:00:00.000Z"),authors:"dean",published:!0,slug:"dns-based-discovery",categories:"research"},i=void 0,s={permalink:"/rlog/dns-based-discovery",source:"@site/rlog/2020-02-7-dns-based-discovery.mdx",title:"DNS Based Discovery",description:"A look at EIP-1459 and the benefits of DNS based discovery.",date:"2020-02-07T12:00:00.000Z",formattedDate:"February 7, 2020",tags:[],readingTime:5.635,hasTruncateMarker:!0,authors:[{name:"Dean",twitter:"DeanEigenmann",github:"decanus",website:"https://dean.eigenmann.me",key:"dean"}],frontMatter:{layout:"post",name:"DNS Based Discovery",title:"DNS Based Discovery",date:"2020-02-07T12:00:00.000Z",authors:"dean",published:!0,slug:"dns-based-discovery",categories:"research"},prevItem:{title:"Waku Update",permalink:"/rlog/waku-update"},nextItem:{title:"Fixing Whisper with Waku",permalink:"/rlog/fixing-whisper-with-waku"}},l={authorsImageUrls:[void 0]},h=[],c={toc:h};function p(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A look at EIP-1459 and the benefits of DNS based discovery."),(0,a.kt)("p",null,"Discovery in p2p networks is the process of how nodes find each other and specific resources they are looking for. Popular discovery protocols, such as ",(0,a.kt)("a",{parentName:"p",href:"https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf"},"Kademlia")," which utilizes a ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Distributed_hash_table"},"distributed hash table")," or DHT, are highly inefficient for resource restricted devices. These methods use short connection windows, and it is quite battery intensive to keep establishing connections. Additionally, we cannot expect a mobile phone for example to synchronize an entire DHT using cellular data."),(0,a.kt)("p",null,"Another issue is how we do the initial bootstrapping. In other words, how does a client find its first node to then discover the rest of the network? In most applications, including Status right now, this is done with a ",(0,a.kt)("a",{parentName:"p",href:"https://rfc.vac.dev/status/deprecated/client/#bootstrapping"},"static list of nodes")," that a client can connect to."),(0,a.kt)("p",null,"In summary, we have a static list that provides us with nodes we can connect to which then allows us to discover the rest of the network using something like Kademlia. But what we need is something that can easily be mutated, guarantees a certain amount of security, and is efficient for resource restricted devices. Ideally our solution would also be robust and scalable."),(0,a.kt)("p",null,"How do we do this?"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1459"},"EIP 1459: Node Discovery via DNS"),", which is one of the strategies we are using for discovering waku nodes. ",(0,a.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1459"},"EIP-1459")," is a DNS-based discovery protocol that stores ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Merkle_tree"},"merkle trees")," in DNS records which contain connection information for nodes."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Waku is our fork of Whisper. Oskar recently wrote an ",(0,a.kt)("a",{parentName:"em",href:"https://vac.dev/fixing-whisper-with-waku"},"entire post")," explaining it. In short, Waku is our method of fixing the shortcomings of Whisper in a more iterative fashion. You can find the specification ",(0,a.kt)("a",{parentName:"em",href:"https://rfc.vac.dev/waku/standards/legacy/6/waku1/"},"here"))),(0,a.kt)("p",null,"DNS-based methods for bootstrapping p2p networks are quite popular. Even Bitcoin uses it, but it uses a concept called DNS seeds, which are just DNS servers that are configured to return a list of randomly selected nodes from the network upon being queried. This means that although these seeds are hardcoded in the client, the IP addresses of actual nodes do not have to be."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"> dig dnsseed.bluematt.me +short\n129.226.73.12\n107.180.78.111\n169.255.56.123\n91.216.149.28\n85.209.240.91\n66.232.124.232\n207.55.53.96\n86.149.241.168\n193.219.38.57\n190.198.210.139\n74.213.232.234\n158.181.226.33\n176.99.2.207\n202.55.87.45\n37.205.10.3\n90.133.4.73\n176.191.182.3\n109.207.166.232\n45.5.117.59\n178.211.170.2\n160.16.0.30\n")),(0,a.kt)("p",null,"The above displays the result of querying on of these DNS seeds. All the nodes are stored as ",(0,a.kt)("a",{parentName:"p",href:"https://simpledns.plus/help/a-records"},(0,a.kt)("inlineCode",{parentName:"a"},"A")," records")," for the given domain name. This is quite a simple solution which Bitcoin almost soley relies on since removing the ",(0,a.kt)("a",{parentName:"p",href:"https://en.bitcoin.it/wiki/Network#IRC"},"IRC bootstrapping method in v0.8.2"),"."),(0,a.kt)("p",null,"What makes this DNS based discovery useful? It allows us to have a mutable list of bootstrap nodes without needing to ship a new version of the client every time a list is mutated. It also allows for a more lightweight method of discovering nodes, something very important for resource restricted devices."),(0,a.kt)("p",null,"Additionally, DNS provides us with a robust and scalable infrastructure. This is due to its hierarchical architecture. This hierarchical architecture also already makes it distributed such that the failure of one DNS server does not result in us no longer being able to resolve our name."),(0,a.kt)("p",null,"As with every solution though, there is a trade-off. By storing the list in DNS name an adversary would simply need to censor the DNS records for a specific name. This would prevent any new client trying to join the network from being able to do so."),(0,a.kt)("p",null,"One thing you notice when looking at ",(0,a.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1459"},"EIP-1459")," is that it is a lot more technically complex than Bitcoin's way of doing this. So if Bitcoin uses this simple method and has proven that it works, why did we need a new method?"),(0,a.kt)("p",null,"There are multiple reasons, but the main one is ",(0,a.kt)("strong",{parentName:"p"},"security"),". In the Bitcoin example, an attacker could create a new list and no one querying would be able to tell. This is however mitigated in ",(0,a.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1459"},"EIP-1459")," where we can verify the integrity of the entire returned list by storing an entire merkle tree in the DNS records."),(0,a.kt)("p",null,"Let's dive into this. Firstly, a client that is using these DNS records for discovery must know the public key corresponding to the private key controlled by the entity creating the list. This is because the entire list is signed using a secp256k1 private key, giving the client the ability to authenticate the list and know that it has not been tampered with by some external party."),(0,a.kt)("p",null,"So that already makes this a lot safer than the method Bitcoin uses. But how are these lists even stored? As previously stated they are stored using ",(0,a.kt)("strong",{parentName:"p"},"merkle trees")," as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The root of the tree is stored in a ",(0,a.kt)("a",{parentName:"p",href:"https://simpledns.plus/help/txt-records"},(0,a.kt)("inlineCode",{parentName:"a"},"TXT")," record"),", this record contains the tree's root hash, a sequence number which is incremented every time the tree is updated and a signature as stated above."),(0,a.kt)("p",{parentName:"li"},"Additionally, there is also a root hash to a second tree called a ",(0,a.kt)("strong",{parentName:"p"},"link tree"),", it contains the information to different lists. This link tree allows us to delegate trust and build a graph of multiple merkle trees stored across multiple DNS names."),(0,a.kt)("p",{parentName:"li"},"The sequence number ensures that an attacker cannot replace a tree with an older version because when a client reads the tree, they should ensure that the sequence number is greater than the last synchronized version.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Using the root hash for the tree, we can find the merkle tree's first branch, the branch is also stored in a ",(0,a.kt)("inlineCode",{parentName:"p"},"TXT")," record. The branch record contains all the hashes of the branch's leafs.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Once a client starts reading all the leafs, they can find one of two things: either a new branch record leading them further down the tree or an Ethereum Name Records (ENR) which means they now have the address of a node to connect to! To learn more about ethereum node records you can have a look at ",(0,a.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-778"},"EIP-778"),", or read a short blog post I wrote explaining them ",(0,a.kt)("a",{parentName:"p",href:"https://dean.eigenmann.me/blog/2020/01/21/network-addresses-in-ethereum/#enr"},"here"),"."))),(0,a.kt)("p",null,"Below is the zone file taken from the ",(0,a.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1459"},"EIP-1459"),", displaying how this looks in practice."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"; name                        ttl     class type  content\n@                             60      IN    TXT   enrtree-root:v1 e=JWXYDBPXYWG6FX3GMDIBFA6CJ4 l=C7HRFPF3BLGF3YR4DY5KX3SMBE seq=1 sig=o908WmNp7LibOfPsr4btQwatZJ5URBr2ZAuxvK4UWHlsB9sUOTJQaGAlLPVAhM__XJesCHxLISo94z5Z2a463gA\nC7HRFPF3BLGF3YR4DY5KX3SMBE    86900   IN    TXT   enrtree://AM5FCQLWIZX2QFPNJAP7VUERCCRNGRHWZG3YYHIUV7BVDQ5FDPRT2@morenodes.example.org\nJWXYDBPXYWG6FX3GMDIBFA6CJ4    86900   IN    TXT   enrtree-branch:2XS2367YHAXJFGLZHVAWLQD4ZY,H4FHT4B454P6UXFD7JCYQ5PWDY,MHTDO6TMUBRIA2XWG5LUDACK24\n2XS2367YHAXJFGLZHVAWLQD4ZY    86900   IN    TXT   enr:-HW4QOFzoVLaFJnNhbgMoDXPnOvcdVuj7pDpqRvh6BRDO68aVi5ZcjB3vzQRZH2IcLBGHzo8uUN3snqmgTiE56CH3AMBgmlkgnY0iXNlY3AyNTZrMaECC2_24YYkYHEgdzxlSNKQEnHhuNAbNlMlWJxrJxbAFvA\nH4FHT4B454P6UXFD7JCYQ5PWDY    86900   IN    TXT   enr:-HW4QAggRauloj2SDLtIHN1XBkvhFZ1vtf1raYQp9TBW2RD5EEawDzbtSmlXUfnaHcvwOizhVYLtr7e6vw7NAf6mTuoCgmlkgnY0iXNlY3AyNTZrMaECjrXI8TLNXU0f8cthpAMxEshUyQlK-AM0PW2wfrnacNI\nMHTDO6TMUBRIA2XWG5LUDACK24    86900   IN    TXT   enr:-HW4QLAYqmrwllBEnzWWs7I5Ev2IAs7x_dZlbYdRdMUx5EyKHDXp7AV5CkuPGUPdvbv1_Ms1CPfhcGCvSElSosZmyoqAgmlkgnY0iXNlY3AyNTZrMaECriawHKWdDRk2xeZkrOXBQ0dfMFLHY4eENZwdufn1S1o\n")),(0,a.kt)("p",null,"All of this has already been introduced into go-ethereum with the pull request ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/ethereum/go-ethereum/pull/20094"},"#20094"),", created by Felix Lange. There's a lot of tooling around it that already exists too which is really cool. So if your project is written in Golang and wants to use this, it's relatively simple! Additionally, here's a proof of concept that shows what this might look like with libp2p on ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/decanus/dns-discovery"},"github"),"."),(0,a.kt)("p",null,"I hope this was a helpful explainer into DNS based discovery, and shows ",(0,a.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1459"},"EIP-1459"),"'s benefits over more traditional DNS-based discovery schemes."))}p.isMDXComponent=!0},3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>u});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),h=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=h(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=h(r),u=a,m=d["".concat(l,".").concat(u)]||d[u]||p[u]||o;return r?n.createElement(m,i(i({ref:t},c),{},{components:r})):n.createElement(m,i({ref:t},c))}));function u(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var h=2;h<o;h++)i[h]=r[h];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"}}]);