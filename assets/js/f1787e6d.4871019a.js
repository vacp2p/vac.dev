"use strict";(self.webpackChunkvac_dev=self.webpackChunkvac_dev||[]).push([[7119],{7351:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/remote-log-5781aa7290ab5e4b5dbf652f5792ef2e.png"},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(96540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}},29695:e=>{e.exports=JSON.parse('{"permalink":"/rlog/remote-log","source":"@site/rlog/2019-10-04-remote-log.mdx","title":"P2P Data Sync with a Remote Log","description":"A research log. Asynchronous P2P messaging? Remote logs to the rescue!","date":"2019-10-04T12:00:00.000Z","tags":[],"readingTime":4.525,"hasTruncateMarker":true,"authors":[{"name":"Oskar","twitter":"oskarth","github":"oskarth","key":"oskarth","page":null}],"frontMatter":{"layout":"post","name":"P2P Data Sync with a Remote Log","title":"P2P Data Sync with a Remote Log","date":"2019-10-04T12:00:00.000Z","authors":"oskarth","published":true,"slug":"remote-log","categories":"research","summary":null,"image":"/img/remote-log.png"},"unlisted":false,"prevItem":{"title":"Feasibility Study: Semaphore rate limiting through zkSNARKs","permalink":"/rlog/feasibility-semaphore-rate-limiting-zksnarks"},"nextItem":{"title":"Vac - A Rough Overview","permalink":"/rlog/vac-overview"}}')},53641:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var s=n(29695),i=n(74848),r=n(28453);const a={layout:"post",name:"P2P Data Sync with a Remote Log",title:"P2P Data Sync with a Remote Log",date:new Date("2019-10-04T12:00:00.000Z"),authors:"oskarth",published:!0,slug:"remote-log",categories:"research",summary:null,image:"/img/remote-log.png"},o=void 0,l={authorsImageUrls:[void 0]},d=[{value:"Remote log",id:"remote-log",level:2},{value:"Definitions",id:"definitions",level:3},{value:"Roles",id:"roles",level:3},{value:"Flow",id:"flow",level:3},{value:"Data format",id:"data-format",level:3},{value:"Interaction with MVDS",id:"interaction-with-mvds",level:3},{value:"Future work",id:"future-work",level:2}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"A research log. Asynchronous P2P messaging? Remote logs to the rescue!"}),"\n","\n",(0,i.jsxs)(t.p,{children:["A big problem when doing end-to-end data sync between mobile nodes is that most devices are offline most of the time. With a naive approach, you quickly run into issues of 'ping-pong' behavior, where messages have to be constantly retransmitted. We saw some basic calculations of what this bandwidth multiplier looks like in a ",(0,i.jsx)(t.a,{href:"https://vac.dev/p2p-data-sync-for-mobile",children:"previous post"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["While you could do some background processing, this is really battery-draining, and on iOS these capabilities are limited. A better approach instead is to loosen the constraint that two nodes need to be online at the same time. How do we do this? There are two main approaches, one is the ",(0,i.jsx)(t.em,{children:"store and forward model"}),", and the other is a ",(0,i.jsx)(t.em,{children:"remote log"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["In the ",(0,i.jsx)(t.em,{children:"store and forward"})," model, we use an intermediate node that forward messages on behalf of the recipient. In the ",(0,i.jsx)(t.em,{children:"remote log"}),' model, you instead replicate the data onto some decentralized storage, and have a mutable reference to the latest state, similar to DNS. While both work, the latter is somewhat more elegant and "pure", as it has less strict requirements of an individual node\'s uptime. Both act as a highly-available cache to smoothen over non-overlapping connection windows between endpoints.']}),"\n",(0,i.jsxs)(t.p,{children:["In this post we are going to describe how such a remote log schema could work. Specifically, how it enhances p2p data sync and takes care of the ",(0,i.jsx)(t.a,{href:"https://vac.dev/p2p-data-sync-for-mobile",children:"following requirements"}),":"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.ol,{start:"3",children:["\n",(0,i.jsx)(t.li,{children:"MUST allow for mobile-friendly usage. By mobile-friendly we mean devices\nthat are resource restricted, mostly-offline and often changing network."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.ol,{start:"4",children:["\n",(0,i.jsx)(t.li,{children:"MAY use helper services in order to be more mobile-friendly. Examples of\nhelper services are decentralized file storage solutions such as IPFS and\nSwarm. These help with availability and latency of data for mostly-offline\ndevices."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"remote-log",children:"Remote log"}),"\n",(0,i.jsx)(t.p,{children:"A remote log is a replication of a local log. This means a node can read data from a node that is offline."}),"\n",(0,i.jsxs)(t.p,{children:["The spec is in an early draft stage and can be found ",(0,i.jsx)(t.a,{href:"https://github.com/vacp2p/specs/pull/16",children:"here"}),". A very basic ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Spike_(software_development)",children:"spike"})," / proof-of-concept can be found ",(0,i.jsx)(t.a,{href:"https://github.com/vacp2p/research/tree/master/remote_log",children:"here"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"definitions",children:"Definitions"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Term"}),(0,i.jsx)(t.th,{children:"Definition"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"CAS"}),(0,i.jsx)(t.td,{children:"Content-addressed storage. Stores data that can be addressed by its hash."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"NS"}),(0,i.jsx)(t.td,{children:"Name system. Associates mutable data to a name."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Remote log"}),(0,i.jsx)(t.td,{children:"Replication of a local log at a different location."})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"roles",children:"Roles"}),"\n",(0,i.jsx)(t.p,{children:"There are four fundamental roles:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Alice"}),"\n",(0,i.jsx)(t.li,{children:"Bob"}),"\n",(0,i.jsx)(t.li,{children:"Name system (NS)"}),"\n",(0,i.jsx)(t.li,{children:"Content-addressed storage (CAS)"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.em,{children:"remote log"})," is the data format of what is stored in the name system."]}),"\n",(0,i.jsx)(t.p,{children:'"Bob" can represent anything from 0 to N participants. Unlike Alice, Bob only needs read-only access to NS and CAS.'}),"\n",(0,i.jsx)(t.h3,{id:"flow",children:"Flow"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Figure 1: Remote log data synchronization.",src:n(7351).A+"",width:"1200",height:"320"})}),"\n",(0,i.jsx)(t.h3,{id:"data-format",children:"Data format"}),"\n",(0,i.jsx)(t.p,{children:"The remote log lets receiving nodes know what data they are missing. Depending on the specific requirements and capabilities of the nodes and name system, the information can be referred to differently. We distinguish between three rough modes:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Fully replicated log"}),"\n",(0,i.jsx)(t.li,{children:"Normal sized page with CAS mapping"}),"\n",(0,i.jsx)(t.li,{children:'"Linked list" mode - minimally sized page with CAS mapping'}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"A remote log is simply a mapping from message identifiers to their corresponding address in a CAS:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Message Identifier (H1)"}),(0,i.jsx)(t.th,{children:"CAS Hash (H2)"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"H1_3"}),(0,i.jsx)(t.td,{children:"H2_3"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"H1_2"}),(0,i.jsx)(t.td,{children:"H2_2"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"H1_1"}),(0,i.jsx)(t.td,{children:"H2_1"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.em,{children:"address to next page"})}),(0,i.jsx)(t.td,{})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"The numbers here corresponds to messages. Optionally, the content itself can be included, just like it normally would be sent over the wire. This bypasses the need for a dedicated CAS and additional round-trips, with a trade-off in bandwidth usage."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Message Identifier (H1)"}),(0,i.jsx)(t.th,{children:"Content"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"H1_3"}),(0,i.jsx)(t.td,{children:"C3"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"H1_2"}),(0,i.jsx)(t.td,{children:"C2"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"H1_1"}),(0,i.jsx)(t.td,{children:"C1"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.em,{children:"address to next page"})}),(0,i.jsx)(t.td,{})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["Both patterns can be used in parallel, e,g. by storing the last ",(0,i.jsx)(t.code,{children:"k"})," messages directly and use CAS pointers for the rest. Together with the ",(0,i.jsx)(t.code,{children:"next_page"})," page semantics, this gives users flexibility in terms of bandwidth and latency/indirection, all the way from a simple linked list to a fully replicated log. The latter is useful for things like backups on durable storage."]}),"\n",(0,i.jsx)(t.h3,{id:"interaction-with-mvds",children:"Interaction with MVDS"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://rfc.vac.dev/vac/2/mvds/#payloads",children:"vac.mvds.Message"})," payloads are the only payloads that MUST be uploaded. Other messages types MAY be uploaded, depending on the implementation."]}),"\n",(0,i.jsx)(t.h2,{id:"future-work",children:"Future work"}),"\n",(0,i.jsx)(t.p,{children:"The spec is still in an early draft stage, so it is expected to change. Same with the proof of concept. More work is needed on getting a fully featured proof of concept with specific CAS and NAS instances. E.g. Swarm and Swarm Feeds, or IPFS and IPNS, or something else."}),"\n",(0,i.jsx)(t.p,{children:"For data sync in general:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Make consistency guarantees more explicit for app developers with support for sequence numbers and DAGs, as well as the ability to send non-synced messages. E.g. ephemeral typing notifications, linear/sequential history and casual consistency/DAG history"}),"\n",(0,i.jsx)(t.li,{children:"Better semantics and scalability for multi-user sync contexts, e.g. CRDTs and joining multiple logs together"}),"\n",(0,i.jsx)(t.li,{children:"Better usability in terms of application layer usage (data sync clients) and supporting more transports"}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.p,{children:["PS1. Thanks everyone who submitted great ",(0,i.jsx)(t.a,{href:"https://explorer.bounties.network/bounty/3389",children:"logo proposals"})," for Vac!"]}),"\n",(0,i.jsxs)(t.p,{children:["PPS2. Next week on October 10th decanus and I will be presenting Vac at ",(0,i.jsx)(t.a,{href:"https://devcon.org/agenda",children:"Devcon"}),", come say hi :)"]})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);