"use strict";(self.webpackChunkvac_dev=self.webpackChunkvac_dev||[]).push([[557],{16918:e=>{e.exports=JSON.parse('{"permalink":"/rlog/kademlia-to-discv5","source":"@site/rlog/2020-04-9-kademlia-to-discv5.mdx","title":"From Kademlia to Discv5","description":"A quick history of discovery in peer-to-peer networks, along with a look into discv4 and discv5, detailing what they are, how they work and where they differ.","date":"2020-04-09T16:00:00.000Z","tags":[],"readingTime":8.055,"hasTruncateMarker":true,"authors":[{"name":"Dean","twitter":"DeanEigenmann","github":"decanus","website":"https://dean.eigenmann.me","key":"dean","page":null}],"frontMatter":{"layout":"post","name":"From Kademlia to Discv5","title":"From Kademlia to Discv5","date":"2020-04-09T16:00:00.000Z","authors":"dean","published":true,"slug":"kademlia-to-discv5","categories":"research"},"unlisted":false,"prevItem":{"title":"What Would a WeChat Replacement Need?","permalink":"/rlog/wechat-replacement-need"},"nextItem":{"title":"Waku Update","permalink":"/rlog/waku-update"}}')},28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>r});var i=s(96540);const n={},a=i.createContext(n);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),i.createElement(a.Provider,{value:t},e.children)}},28651:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var i=s(16918),n=s(74848),a=s(28453);const o={layout:"post",name:"From Kademlia to Discv5",title:"From Kademlia to Discv5",date:new Date("2020-04-09T16:00:00.000Z"),authors:"dean",published:!0,slug:"kademlia-to-discv5",categories:"research"},r=void 0,d={authorsImageUrls:[void 0]},l=[{value:"The Beginning",id:"the-beginning",level:2},{value:"Distributed Hash Tables",id:"distributed-hash-tables",level:2},{value:"Kademlia",id:"kademlia",level:2},{value:"Discv4",id:"discv4",level:2},{value:"Discv5",id:"discv5",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"A quick history of discovery in peer-to-peer networks, along with a look into discv4 and discv5, detailing what they are, how they work and where they differ."}),"\n","\n",(0,n.jsxs)(t.p,{children:["If you've been working on Ethereum or adjacent technologies you've probably heard of ",(0,n.jsx)(t.a,{href:"https://github.com/ethereum/devp2p/blob/master/discv4.md",children:"discv4"})," or ",(0,n.jsx)(t.a,{href:"https://github.com/ethereum/devp2p/blob/master/discv5/discv5.md",children:"discv5"}),". But what are they actually? How do they work and what makes them different? To answer these questions, we need to start at the beginning, so this post will assume that there is little knowledge on the subject so the post should be accessible for anyone."]}),"\n",(0,n.jsx)(t.h2,{id:"the-beginning",children:"The Beginning"}),"\n",(0,n.jsx)(t.p,{children:"Let's start right at the beginning: the problem of discovery and organization of nodes in peer-to-peer networks."}),"\n",(0,n.jsx)(t.p,{children:"Early P2P file sharing technologies, such as Napster, would share information about who holds what file using a single server. A node would connect to the central server and give it a list of the files it owns. Another node would then connect to that central server, find a node that has the file it is looking for and contact that node. This however was a flawed system -- it was vulnerable to attacks and left a single party open to lawsuits."}),"\n",(0,n.jsx)(t.p,{children:"It became clear that another solution was needed, and after years of research and experimentation, we were given the distributed hash table or DHT."}),"\n",(0,n.jsx)(t.h2,{id:"distributed-hash-tables",children:"Distributed Hash Tables"}),"\n",(0,n.jsxs)(t.p,{children:["In 2001 4 new protocols for such DHTs were conceived, ",(0,n.jsx)(t.a,{href:"https://pdos.csail.mit.edu/~strib/docs/tapestry/tapestry_jsac03.pdf",children:"Tapestry"}),", ",(0,n.jsx)(t.a,{href:"https://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf",children:"Chord"}),", ",(0,n.jsx)(t.a,{href:"https://people.eecs.berkeley.edu/~sylvia/papers/cans.pdf",children:"CAN"})," and ",(0,n.jsx)(t.a,{href:"http://rowstron.azurewebsites.net/PAST/pastry.pdf",children:"Pastry"}),", all of which made various trade-offs and changes in their core functionality, giving them unique characteristics."]}),"\n",(0,n.jsx)(t.p,{children:"But as said, they're all DHTs. So what is a DHT?"}),"\n",(0,n.jsx)(t.p,{children:"A distributed hash table (DHT) is essentially a distributed key-value list. Nodes participating in the DHT can easily retrieve the value for a key."}),"\n",(0,n.jsx)(t.p,{children:"If we have a network with 9 key-value pairs and 3 nodes, ideally each node would store 3 (optimally 6 for redundancy) of those key-value pairs, meaning that if a key-value pair were to be updated, only part of the network would responsible for ensuring that it is. The idea is that any node in the network would know where to find the specific key-value pair it is looking for based on how things are distributed amongst the nodes."}),"\n",(0,n.jsx)(t.h2,{id:"kademlia",children:"Kademlia"}),"\n",(0,n.jsx)(t.p,{children:"So now that we know what DHTs are, let's get to Kademlia, the predecessor of discv4. Kademlia was created by Petar Maymounkov and David Mazi\xe8res in 2002. I will naively say that this is probably one of the most popular and most used DHT protocols. It's quite simple in how it works, so let's look at it."}),"\n",(0,n.jsx)(t.p,{children:"In Kademlia, nodes and values are arranged by distance (in a very mathematical definition). This distance is not a geographical one, but rather based on identifiers. It is calculated how far 2 identifiers are from eachother using some distance function."}),"\n",(0,n.jsxs)(t.p,{children:["Kademlia uses an ",(0,n.jsx)(t.code,{children:"XOR"})," as its distance function. An ",(0,n.jsx)(t.code,{children:"XOR"})," is a function that outputs ",(0,n.jsx)(t.code,{children:"true"})," only when inputs differ. Here is an example with some binary identifiers:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"XOR 10011001\n    00110010\n    --------\n    10101011\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The top in decimal numbers means that the distance between ",(0,n.jsx)(t.code,{children:"153"})," and ",(0,n.jsx)(t.code,{children:"50"})," is ",(0,n.jsx)(t.code,{children:"171"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["There are several reasons why ",(0,n.jsx)(t.code,{children:"XOR"})," was taken:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["The distance from one ID to itself will be ",(0,n.jsx)(t.code,{children:"0"}),"."]}),"\n",(0,n.jsx)(t.li,{children:"Distance is symmetric, A to B is the same as B to A."}),"\n",(0,n.jsxs)(t.li,{children:["Follows triangle inequality, if ",(0,n.jsx)(t.code,{children:"A"}),", ",(0,n.jsx)(t.code,{children:"B"})," and ",(0,n.jsx)(t.code,{children:"C"})," are points on a triangle then the distance ",(0,n.jsx)(t.code,{children:"A"})," to ",(0,n.jsx)(t.code,{children:"B"})," is closer or equal to that of ",(0,n.jsx)(t.code,{children:"A"})," to ",(0,n.jsx)(t.code,{children:"C"})," plus the one from ",(0,n.jsx)(t.code,{children:"B"})," to ",(0,n.jsx)(t.code,{children:"C"}),"."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:'In summary, this distance function allows a node to decide what is "close" to it and make decisions based on that "closeness".'}),"\n",(0,n.jsx)(t.p,{children:"Kademlia nodes store a routing table. This table contains multiple lists. Each subsequent list contains nodes which are a little further distanced than the ones included in the previous list. Nodes maintain detailed knowledge about nodes closest to them, and the further away a node is, the less knowledge the node maintains about it."}),"\n",(0,n.jsx)(t.p,{children:"So let's say I want to find a specific node. What I would do is go to any node which I already know and ask them for all their neighbours closest to my target. I repeat this process for the returned neighbours until I find my target."}),"\n",(0,n.jsx)(t.p,{children:"The same thing happens for values. Values have a certain distance from nodes and their IDs are structured the same way so we can calculate this distance. If I want to find a value, I simply look for the neighbours closest to that value's key until I find the one storing said value."}),"\n",(0,n.jsx)(t.p,{children:"For Kademlia nodes to support these functions, there are several messages with which the protocol communicates."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"PING"})," - Used to check whether a node is still running."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"STORE"})," - Stores a value with a given key on a node."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"FINDNODE"})," - Returns the closest nodes requested to a given ID."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"FINDVALUE"})," - The same as ",(0,n.jsx)(t.code,{children:"FINDNODE"}),", except if a node stores the specific value it will return it directly."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsxs)(t.em,{children:["This is a ",(0,n.jsx)(t.strong,{children:"very"})," simplified explanation of Kademlia and skips various important details. For the full description, make sure to check out the ",(0,n.jsx)(t.a,{href:"https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf",children:"paper"})," or a more in-depth ",(0,n.jsx)(t.a,{href:"http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html",children:"design specification"})]})}),"\n",(0,n.jsx)(t.h2,{id:"discv4",children:"Discv4"}),"\n",(0,n.jsx)(t.p,{children:"Now after that history lesson, we finally get to discv4 (which stands for discovery v4), Ethereum's current node discovery protocol. The protocol itself is essentially based off of Kademlia, however it does away with certain aspects of it. For example, it does away with any usage of the value part of the DHT."}),"\n",(0,n.jsxs)(t.p,{children:["Kademlia is mainly used for the organisation of the network, so we only use the routing table to locate other nodes. Due to the fact that discv4 doesn't use the value portion of the DHT at all, we can throw away the ",(0,n.jsx)(t.code,{children:"FINDVALUE"})," and ",(0,n.jsx)(t.code,{children:"STORE"})," commands described by Kademlia."]}),"\n",(0,n.jsx)(t.p,{children:"The lookup method previously described by Kademlia describes how a node gets its peers. A node contacts some node and asks it for the nodes closest to itself. It does so until it can no longer find any new nodes."}),"\n",(0,n.jsxs)(t.p,{children:["Additionally, discv4 adds mutual endpoint verification. This is meant to ensure that a peer calling ",(0,n.jsx)(t.code,{children:"FINDNODE"})," also participates in the discovery protocol."]}),"\n",(0,n.jsxs)(t.p,{children:["Finally, all discv4 nodes are expected to maintain up-to-date ENR records. These contain information about a node. They can be requested from any node using a discv4-specific packet called ",(0,n.jsx)(t.code,{children:"ENRRequest"}),"."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsxs)(t.em,{children:["If you want some more details on ENRs, check out one of my posts ",(0,n.jsx)(t.a,{href:"https://dean.eigenmann.me/blog/2020/01/21/network-addresses-in-ethereum/",children:'"Network Addresses in Ethereum"'})]})}),"\n",(0,n.jsx)(t.p,{children:"Discv4 comes with its own range of problems however. Let's look at a few of them."}),"\n",(0,n.jsx)(t.p,{children:"Firstly, the way discv4 works right now, there is no way to differentiate between node sub-protocols. This means for example that an Ethereum node could add an Ethereum Classic Node, Swarm or Whisper node to its DHT without realizing that it is invalid until more communication has happened. This inability to differentiate sub-protocols makes it harder to find specific nodes, such as Ethereum nodes with light-client support."}),"\n",(0,n.jsxs)(t.p,{children:["Next, in order to prevent replay attacks, discv4 uses timestamps. This however can lead to various issues when a host's clock is wrong. For more details, see the ",(0,n.jsx)(t.a,{href:"https://github.com/ethereum/devp2p/blob/master/discv4.md#known-issues-in-the-current-version",children:'"Known Issues"'})," section of the discv4 specification."]}),"\n",(0,n.jsxs)(t.p,{children:["Finally, we have an issue with the way mutual endpoint verification works. Messages can get dropped and there is no way to tell if both peers have verified eachother. This means that we could consider our peer verified while it does not consider us so making them drop the ",(0,n.jsx)(t.code,{children:"FINDNODE"})," packet."]}),"\n",(0,n.jsx)(t.h2,{id:"discv5",children:"Discv5"}),"\n",(0,n.jsx)(t.p,{children:"Finally, let's look at discv5. The next iteration of discv4 and the discovery protocol which will be used by Eth 2.0. It aims at fixing various issues present in discv4."}),"\n",(0,n.jsxs)(t.p,{children:["The first change is the way ",(0,n.jsx)(t.code,{children:"FINDNODE"})," works. In traditional Kademlia as well as in discv5, we pass an identifier. However, in discv5 we instead pass the logarithmic distance, meaning that a ",(0,n.jsx)(t.code,{children:"FINDNODE"})," request gets a response containing all nodes at the specified logarithmic distance from the called node."]}),"\n",(0,n.jsx)(t.p,{children:"Logarithmic distance means we first calculate the distance and then run it through our log base 2 function. See:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"log2(A xor B)\n"})}),"\n",(0,n.jsxs)(t.p,{children:["And the second, more important change, is that discv5 aims at solving one of the biggest issues of discv4: the differentiation of sub-protocols. It does this by adding topic tables. Topic tables are ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)",children:"first in first out"})," lists that contain nodes which have advertised that they provide a specific service. Nodes get themselves added to this list by registering ",(0,n.jsx)(t.code,{children:"ads"})," on their peers."]}),"\n",(0,n.jsxs)(t.p,{children:["As of writing, there is still an issue with this proposal. There is currently no efficient way for a node to place ",(0,n.jsx)(t.code,{children:"ads"})," on multiple peers, since it would require separate requests for every peer which is inefficient in a large-scale network."]}),"\n",(0,n.jsxs)(t.p,{children:["Additionally, it is unclear how many peers a node should place these ",(0,n.jsx)(t.code,{children:"ads"})," on and exactly which peers to place them on. For more details, check out the issue ",(0,n.jsx)(t.a,{href:"https://github.com/ethereum/devp2p/issues/136",children:"devp2p#136"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"There are a bunch more smaller changes to the protocol, but they are less important hence they were ommitted from this summary."}),"\n",(0,n.jsx)(t.p,{children:"Nevertheless, discv5 still does not resolve a couple issues present in discv4, such as unreliable endpoint verification. As of writing this post, there is currently no new method in discv5 to improve the endpoint verification process."}),"\n",(0,n.jsx)(t.p,{children:"As you can see discv5 is still a work in progress and has a few large challenges to overcome. However if it does, it will most likely be a large improvement to a more naive Kademlia implementations."}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.p,{children:["Hopefully this article helped explain what these discovery protocols are and how they work. If you're interested in their full specifications you can find them on ",(0,n.jsx)(t.a,{href:"https://github.com/ethereum/devp2p",children:"github"}),"."]})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}}}]);