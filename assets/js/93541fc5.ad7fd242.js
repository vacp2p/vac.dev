"use strict";(self.webpackChunkvac_dev=self.webpackChunkvac_dev||[]).push([[1773],{76944:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var n=a(87462),i=(a(67294),a(3905));const r={title:"zkVM Testing Report: Evaluating Zero-Knowledge Virtual Machines for Nescience",date:new Date("2024-09-26T12:00:00.000Z"),authors:"moudy",published:!0,slug:"zkVM-testing",categories:"research",discuss:"https://forum.vac.dev/t/zkvm-testing-report-evaluating-zero-knowledge-virtual-machines-for-nescience/",toc_min_heading_level:2,toc_max_heading_level:5},l=void 0,s={permalink:"/rlog/zkVM-testing",source:"@site/rlog/2024-09-26-Zkvm-testing.mdx",title:"zkVM Testing Report: Evaluating Zero-Knowledge Virtual Machines for Nescience",description:"Following our initial exploration of zkVMs in our previous blog post [1],",date:"2024-09-26T12:00:00.000Z",formattedDate:"September 26, 2024",tags:[],readingTime:11.985,hasTruncateMarker:!0,authors:[{name:"Moudy",github:"moudyellaz",key:"moudy"}],frontMatter:{title:"zkVM Testing Report: Evaluating Zero-Knowledge Virtual Machines for Nescience",date:"2024-09-26T12:00:00.000Z",authors:"moudy",published:!0,slug:"zkVM-testing",categories:"research",discuss:"https://forum.vac.dev/t/zkvm-testing-report-evaluating-zero-knowledge-virtual-machines-for-nescience/",toc_min_heading_level:2,toc_max_heading_level:5},nextItem:{title:"Exploring zkVMs: Which Projects Truly Qualify as Zero-Knowledge Virtual Machines?",permalink:"/rlog/zkVM-explorations"}},o={authorsImageUrls:[void 0]},p=[{value:"1. SP1",id:"1-sp1",level:3},{value:"2. RISC0",id:"2-risc0",level:3},{value:"3. Nexus",id:"3-nexus",level:3},{value:"4. ZkMIPS",id:"4-zkmips",level:3},{value:"5. ZkWASM",id:"5-zkwasm",level:3},{value:"6. Valida",id:"6-valida",level:3},{value:"Summary table",id:"summary-table",level:2},{value:"Stage 1",id:"stage-1",level:3},{value:"Stage 2",id:"stage-2",level:3}],m={toc:p};function c(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Following our initial exploration of zkVMs in our previous blog post [",(0,i.kt)("a",{parentName:"p",href:"https://vac.dev/rlog/zkVM-explorations/"},"1"),"],\nwe have conducted a series of tests to identify the most suitable zkVM for the Nescience architecture [",(0,i.kt)("a",{parentName:"p",href:"https://vac.dev/rlog/Nescience-state-separation-architecture"},"2"),"].\nThis post outlines the testing process, results, and conclusions. Additionally, the full test suite and scripts can be found\non our GitHub page [",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vacp2p/nescience-zkvm-testing"},"3"),"], allowing others to replicate the results or explore the candidates further.\nPlease note that we chose not to use hardware acceleration in our benchmarks, as our project is aimed at a broad audience.\nParticularly, we cannot assume AVX512 support by default, as it is typically available only in high-end CPUs."),(0,i.kt)("p",null,"We've shortlisted the following zkVMs for testing:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"SP1 [",(0,i.kt)("a",{parentName:"li",href:"https://blog.succinct.xyz/introducing-sp1/"},"4"),"]"),(0,i.kt)("li",{parentName:"ul"},"RISC0 [",(0,i.kt)("a",{parentName:"li",href:"https://www.risczero.com/zkvm"},"5"),"]"),(0,i.kt)("li",{parentName:"ul"},"Nexus [",(0,i.kt)("a",{parentName:"li",href:"https://docs.nexus.xyz/"},"6"),"]"),(0,i.kt)("li",{parentName:"ul"},"ZkMIPS [",(0,i.kt)("a",{parentName:"li",href:"https://docs.zkm.io/zkm-architecture"},"7"),"]"),(0,i.kt)("li",{parentName:"ul"},"ZkWASM [",(0,i.kt)("a",{parentName:"li",href:"https://delphinuslab.com/zk-wasm/"},"8"),"]"),(0,i.kt)("li",{parentName:"ul"},"Valida [",(0,i.kt)("a",{parentName:"li",href:"https://delendum.xyz/writings/2023-05-10-zkvm-design.html"},"9"),"]")),(0,i.kt)("h1",{id:"why-these-candidates"},"Why these candidates?"),(0,i.kt)("p",null,"When narrowing down the zkVMs, we focused on key factors:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"True zero-knowledge functionality: The zkVMs had to demonstrate or be close to demonstrating the ability to generate and verify zero-knowledge proofs."),(0,i.kt)("li",{parentName:"ul"},"Performance baselines: We sought zkVMs with solid benchmarks in performance, particularly in speed and efficiency."),(0,i.kt)("li",{parentName:"ul"},"Specific functionalities: For Nescience, functionalities like lookup tables, precompiles, and recursive capabilities are critical. ")),(0,i.kt)("p",null,"We need a zkVM that supports these to enable robust project development."),(0,i.kt)("h1",{id:"preliminary-information-on-the-candidates"},"Preliminary information on the candidates"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"SP1 is a performant, open-source zkVM that verifies the execution of arbitrary Rust (or any LLVM-compiled language) programs.\nSP1 utilizes Plonky3, enabling recursive proofs and supporting a wide range of cryptographic algorithms, including ECC-based ones like Groth16.\nWhile it supports aggregation, it appears not to support zero knowledge in a conventional manner.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"RISC0 zkVM allows one to prove the correct execution of arbitrary Rust code. Built on a RISC-V architecture, it is inherently adaptable\nfor implementing standard cryptographic hash functions such as SHA-256 and ECDSA. RISC0 employs STARKs, providing a security level of 98 bits.\nIt supports multiple programming languages, including C and Rust, thanks to its compatibility with LLVM and WASM.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Nexus is a modular, extensible, open-source, highly parallelized, prover-optimized, and contributor-friendly zkVM written in Rust.\nIt focuses on performance and security, using the Nova folding scheme, which is particularly effective for recursive proofs.\nNexus also supports precompiles and targeted compilation, and besides Rust, it offers C++ support.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"ZkMIPS is a general verifiable computing infrastructure based on Plonky2 and the MIPS microarchitecture, aiming to empower Ethereum\nas a global settlement layer. It can run arbitrary Rust code as well. Notably, zkMIPS is the only zkVM in this list that utilizes the MIPS opcode set.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"ZkWASM adheres to and supports the unmodified standard WASM bytecode specification. Since Rust code can be compiled to WASM bytecode,\none could theoretically run any Rust code on a zkWASM machine, providing flexibility and broad language support.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Valida is a STARK-based virtual machine aiming to improve upon the state of the art in several categories:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Code reuse: The VM has a RISC-inspired instruction set, simplifying the targeting of conventional programming languages.\nA backend compiler is being developed to compile LLVM IR to the Valida ISA, enabling the proving of programs written in Rust,\nGo, C++, and others with minimal to no changes in source code."),(0,i.kt)("li",{parentName:"ul"},"Prover performance: Engineered to maximize prover performance, Valida is compatible with a 31-bit field, restricted to degree 3 constraints,\nand features minimal instruction decoding. It operates directly on memory without general-purpose registers or a dedicated stack,\nutilizing newer lookup arguments to reduce trace overhead involved in cross-chip communication."),(0,i.kt)("li",{parentName:"ul"},"Extensibility: Designed to be customizable, Valida can easily be extended to include an arbitrary number of user-defined instructions.\nProcedural macros are used to construct the desired machine at compile time, avoiding any runtime penalties.")))),(0,i.kt)("p",null,"Valida appears to be in the early stages of development but already showcases respectable performance metrics."),(0,i.kt)("h1",{id:"testing-plan"},"Testing plan"),(0,i.kt)("p",null,"To thoroughly evaluate each zkVM, we devised a two-stage testing process:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Stage 1: Arithmetic operations"),(0,i.kt)("p",{parentName:"li"},"  The first phase focused on evaluating the zkVMs\u2019 ability to handle basic arithmetic operations: addition, subtraction, multiplication,\ndivision, modulus division, and square root calculations. We designed the test around heptagonal numbers, which required zkVMs to process\nmultiple arithmetic operations simultaneously. By using this method, we could measure efficiency and speed in handling complex mathematical calculations \u2013\na crucial element for zkVM performance. ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Stage 2: Memory consumption"),(0,i.kt)("p",{parentName:"li"},"  For the second phase, we evaluated each zkVM\u2019s ability to manage memory under heavy loads. We tested several data structures, including lists,\nhash maps, deques, queues, BTreeMaps, hash sets, and binary heaps. Each zkVM underwent tests for the following operations:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Insert: How quickly can the zkVM add data to structures?"),(0,i.kt)("li",{parentName:"ul"},"Delete: Does the zkVM handle memory release effectively?"),(0,i.kt)("li",{parentName:"ul"},"Append: Can the zkVM efficiently grow data structures?"),(0,i.kt)("li",{parentName:"ul"},"Search: How fast and efficient is the zkVM when retrieving stored data?")))),(0,i.kt)("p",null,"The purpose of this stage was to identify any memory bottlenecks and to determine whether a zkVM could manage high-intensity tasks efficiently,\nsomething vital for the Nescience project\u2019s complex, data-heavy processes."),(0,i.kt)("h1",{id:"machine-specifications"},"Machine specifications"),(0,i.kt)("p",null,"The tests were conducted on the following hardware configuration:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'CPU: AMD EPYC 7713 "Milan" 64-core processor (128 threads total)'),(0,i.kt)("li",{parentName:"ul"},"RAM: 600GiB DDR4 3200MHz ECC RAM, distributed across 16 DIMMs"),(0,i.kt)("li",{parentName:"ul"},"Host OS: Proxmox 8.3"),(0,i.kt)("li",{parentName:"ul"},"Hypervisor: KVM"),(0,i.kt)("li",{parentName:"ul"},"Network layer: Open vSwitch"),(0,i.kt)("li",{parentName:"ul"},"Machine model: Supermicro AS-2024US-TRT")),(0,i.kt)("h1",{id:"results"},"Results"),(0,i.kt)("h3",{id:"1-sp1"},"1. SP1"),(0,i.kt)("p",null,"SP1 does not provide zero-knowledge capability in its proofs but delivers respectable performance, though slightly behind its main competitor.\nMemory leaks were minimal, staying below the 700 KB threshold. Interestingly, SP1 consumed more RAM during the basic arithmetic\ntest than in memory allocation tests, showcasing the team's effective handling of memory under load. In the basic test,\nallocations were primarily in the 9-16 B, 33-64 B, and 65-128 B ranges. For memory allocations, most fell into the 129-256 B range."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Stage 1: Hept 100 test",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Proof size: 3.108 MB"),(0,i.kt)("li",{parentName:"ul"},"Proof time: 16.95 seconds")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 1",src:a(89203).Z,width:"1318",height:"778"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 2",src:a(93795).Z,width:"1310",height:"797"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 3",src:a(11611).Z,width:"1307",height:"796"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 4",src:a(38337).Z,width:"1308",height:"796"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 5",src:a(48805).Z,width:"1308",height:"798"}))))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Stage 2: Vec 10000 test",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Proof size: 3.17 MB"),(0,i.kt)("li",{parentName:"ul"},"Proof time: 20.85 seconds")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 1",src:a(81581).Z,width:"1316",height:"777"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 2",src:a(64082).Z,width:"1320",height:"794"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 3",src:a(90460).Z,width:"1317",height:"799"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 4",src:a(423).Z,width:"1319",height:"798"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 5",src:a(24860).Z,width:"1324",height:"793"}))))),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"2-risc0"},"2. RISC0"),(0,i.kt)("p",null,"RISC0 stands out with exceptional performance in proof size and generation time, ranking among the best\n(with the exception of Valida and zkWASM's basic test). It also handles memory well, with minor leaks under 0.5 MB\nand controlled RAM consumption staying below 2.2 GB. RISC0's memory allocations were consistent, primarily in the 17-32 B and 33-64 B ranges."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Stage 1: Hept 100 test",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Proof size: 217.4 KB"),(0,i.kt)("li",{parentName:"ul"},"Proof time: 9.73 seconds")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 1",src:a(1459).Z,width:"1324",height:"759"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 2",src:a(59108).Z,width:"1314",height:"799"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 3",src:a(64450).Z,width:"1315",height:"798"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 4",src:a(17410).Z,width:"1315",height:"801"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 5",src:a(85209).Z,width:"1322",height:"800"}))))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Stage 2: Vec 10000 test",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Proof size: 217.4 KB"),(0,i.kt)("li",{parentName:"ul"},"Proof time: 16.63 seconds")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 1",src:a(84606).Z,width:"1322",height:"773"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 2",src:a(38538).Z,width:"1317",height:"803"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 3",src:a(80247).Z,width:"1318",height:"801"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 4",src:a(26210).Z,width:"1319",height:"799"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 5",src:a(76245).Z,width:"1316",height:"800"}))))),(0,i.kt)("p",null,"Based on these results, RISC0 is a solid candidate for Nescience."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"3-nexus"},"3. Nexus"),(0,i.kt)("p",null,"Nexus' performance offers interesting insights into folding scheme-based zkVMs. Surprisingly, proof sizes remained consistent\nregardless of workload, with no significant memory leaks (under 700 KB). However, while RAM consumption increased slightly with higher\nworkloads (up to 1.2 GB), Nexus performed poorly during memory allocation tests, making it unsuitable for our use case."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Allocation details:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Basic test: Most allocations concentrated in 65-128 B"),(0,i.kt)("li",{parentName:"ul"},"Memory-heavy test: Allocations in the 129-256 B range"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Stage 1: Hept 100 test"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Proof size: 46 MB"),(0,i.kt)("li",{parentName:"ul"},"Proof time: 12.06 seconds")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 1",src:a(25693).Z,width:"1325",height:"776"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 2",src:a(80370).Z,width:"1321",height:"807"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 3",src:a(29530).Z,width:"1316",height:"800"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 4",src:a(87538).Z,width:"1313",height:"801"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 5",src:a(3240).Z,width:"1321",height:"793"}))))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Stage 2: Vec 10000 test",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Proof size: 46 MB"),(0,i.kt)("li",{parentName:"ul"},"Proof time: 56 minutes")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 1",src:a(4327).Z,width:"1318",height:"776"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 2",src:a(61544).Z,width:"1320",height:"804"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 3",src:a(61258).Z,width:"1315",height:"798"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 4",src:a(20297).Z,width:"1322",height:"795"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 5",src:a(83519).Z,width:"1312",height:"804"}))))),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"4-zkmips"},"4. ZkMIPS"),(0,i.kt)("p",null,"ZkMIPS presents an intriguing case. While it shows good results in terms of proof size and generation time during the basic test,\nthese come at the cost of significant RAM usage and memory leaks. The memory allocation test revealed a concerning 6.7 GB memory leak,\nwith 0.5 GB leaked during the basic test. Despite this, RAM consumption (while high at 17+ GB) remains stable under higher workloads.\nAllocation sizes are spread across several ranges, with notable concentrations in the 17-32 B, 65-128 B, and 257-512 B slots."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Stage 1: Hept 100 test",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Proof size: 4.3 MB"),(0,i.kt)("li",{parentName:"ul"},"Proof time: 9.32 seconds")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 1",src:a(42204).Z,width:"1323",height:"779"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 2",src:a(85554).Z,width:"1321",height:"803"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 3",src:a(85465).Z,width:"1316",height:"802"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 4",src:a(8839).Z,width:"1317",height:"806"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 5",src:a(64125).Z,width:"1307",height:"806"}))))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Stage 2: Vec 10000 test",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Proof size: 4.898 MB"),(0,i.kt)("li",{parentName:"ul"},"Proof time: 42.57 seconds")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 1",src:a(62942).Z,width:"1324",height:"776"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 2",src:a(74498).Z,width:"1312",height:"800"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 3",src:a(1484).Z,width:"1314",height:"801"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 4",src:a(72683).Z,width:"1310",height:"800"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 5",src:a(13077).Z,width:"1305",height:"800"}))))),(0,i.kt)("p",null,"This zkVM provides mixed results with strong proof generation but concerning memory management issues."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"5-zkwasm"},"5. ZkWASM"),(0,i.kt)("p",null,"ZkWASM, unfortunately, performed poorly in both stages regarding proof size and generation time. RAM consumption was particularly high,\nexceeding 7 GB in the basic test, and an astounding 57 GB during memory allocation tests. Despite its impressive memory usage,\nthe proof sizes were relatively large at 18 KB and 334 KB respectively. Allocation sizes were mainly concentrated in the 33-64 B range,\nwith neighboring slots contributing small but notable amounts."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Stage 1: Hept 100 test",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Proof size: 18 KB"),(0,i.kt)("li",{parentName:"ul"},"Proof time: 42.7 seconds")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 1",src:a(81969).Z,width:"1321",height:"778"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 2",src:a(68593).Z,width:"1314",height:"802"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 3",src:a(73312).Z,width:"1314",height:"803"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 4",src:a(49155).Z,width:"1313",height:"808"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 5",src:a(19895).Z,width:"1304",height:"803"}))))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Stage 2: Vec 10000 test",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Proof size: 334 KB"),(0,i.kt)("li",{parentName:"ul"},"Proof time: 323 seconds")))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 1",src:a(92076).Z,width:"1322",height:"773"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 2",src:a(34403).Z,width:"1324",height:"791"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 3",src:a(54443).Z,width:"1315",height:"799"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 4",src:a(4229).Z,width:"1324",height:"803"})),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("img",{alt:"Image 5",src:a(72106).Z,width:"1322",height:"803"}))))),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"6-valida"},"6. Valida"),(0,i.kt)("p",null,"Valida delivered impressive results in proof generation speed and size, with a proof size of 280 KB and a proof time of < 1 second.\nHowever, profiling was not possible due to Valida's limited Rust support. Valida currently compiles Rust using the LLVM backend,\ntranspiling LLVM IR to leverage its C/C++ implementation, which leads to errors when handling Rust-specific data structures or dependencies.\nAs a result, complex memory interactions couldn't be tested, and using Valida with Rust code is currently not advisable.\nA GitHub issue has been opened to address this."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"summary-table"},"Summary table"),(0,i.kt)("h3",{id:"stage-1"},"Stage 1"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"zkVM"),(0,i.kt)("th",{parentName:"tr",align:null},"Proof time"),(0,i.kt)("th",{parentName:"tr",align:null},"Proof size"),(0,i.kt)("th",{parentName:"tr",align:null},"Peak RAM consumption"),(0,i.kt)("th",{parentName:"tr",align:null},"Memory leaked"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SP1"),(0,i.kt)("td",{parentName:"tr",align:null},"16.95 s"),(0,i.kt)("td",{parentName:"tr",align:null},"3.108 MB"),(0,i.kt)("td",{parentName:"tr",align:null},"2.1 GB"),(0,i.kt)("td",{parentName:"tr",align:null},"656.8 KB")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"RISC0"),(0,i.kt)("td",{parentName:"tr",align:null},"9.73 s"),(0,i.kt)("td",{parentName:"tr",align:null},"217.4 KB"),(0,i.kt)("td",{parentName:"tr",align:null},"1.9 GB"),(0,i.kt)("td",{parentName:"tr",align:null},"470.5 KB")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Nexus"),(0,i.kt)("td",{parentName:"tr",align:null},"12.06 s"),(0,i.kt)("td",{parentName:"tr",align:null},"46 MB"),(0,i.kt)("td",{parentName:"tr",align:null},"9.7 MB"),(0,i.kt)("td",{parentName:"tr",align:null},"646.5 KB")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZkMIPS"),(0,i.kt)("td",{parentName:"tr",align:null},"9.32 s"),(0,i.kt)("td",{parentName:"tr",align:null},"4.3 MB"),(0,i.kt)("td",{parentName:"tr",align:null},"17.3 GB"),(0,i.kt)("td",{parentName:"tr",align:null},"453.8 MB")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZkWASM"),(0,i.kt)("td",{parentName:"tr",align:null},"42.7 s"),(0,i.kt)("td",{parentName:"tr",align:null},"18 KB"),(0,i.kt)("td",{parentName:"tr",align:null},"8.2 GB"),(0,i.kt)("td",{parentName:"tr",align:null},"259.4 KB")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Valida"),(0,i.kt)("td",{parentName:"tr",align:null},"< 1 s"),(0,i.kt)("td",{parentName:"tr",align:null},"280 KB"),(0,i.kt)("td",{parentName:"tr",align:null},"N/A"),(0,i.kt)("td",{parentName:"tr",align:null},"N/A")))),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"stage-2"},"Stage 2"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"zkVM"),(0,i.kt)("th",{parentName:"tr",align:null},"Proof time"),(0,i.kt)("th",{parentName:"tr",align:null},"Proof size"),(0,i.kt)("th",{parentName:"tr",align:null},"Peak RAM consumption"),(0,i.kt)("th",{parentName:"tr",align:null},"Memory leaked"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SP1"),(0,i.kt)("td",{parentName:"tr",align:null},"20.85 s"),(0,i.kt)("td",{parentName:"tr",align:null},"3.17 MB"),(0,i.kt)("td",{parentName:"tr",align:null},"1.9 GB"),(0,i.kt)("td",{parentName:"tr",align:null},"616 KB")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"RISC0"),(0,i.kt)("td",{parentName:"tr",align:null},"16.63 s"),(0,i.kt)("td",{parentName:"tr",align:null},"217.4 KB"),(0,i.kt)("td",{parentName:"tr",align:null},"2.3 GB"),(0,i.kt)("td",{parentName:"tr",align:null},"485.3 KB")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Nexus"),(0,i.kt)("td",{parentName:"tr",align:null},"56 m"),(0,i.kt)("td",{parentName:"tr",align:null},"46 MB"),(0,i.kt)("td",{parentName:"tr",align:null},"1.9 GB"),(0,i.kt)("td",{parentName:"tr",align:null},"616 KB")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZkMIPS"),(0,i.kt)("td",{parentName:"tr",align:null},"42.57 s"),(0,i.kt)("td",{parentName:"tr",align:null},"4.898 MB"),(0,i.kt)("td",{parentName:"tr",align:null},"18.9 GB"),(0,i.kt)("td",{parentName:"tr",align:null},"6.9 GB")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZkWASM"),(0,i.kt)("td",{parentName:"tr",align:null},"323 s"),(0,i.kt)("td",{parentName:"tr",align:null},"334 KB"),(0,i.kt)("td",{parentName:"tr",align:null},"58.8 GB"),(0,i.kt)("td",{parentName:"tr",align:null},"259.4 KB")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Valida"),(0,i.kt)("td",{parentName:"tr",align:null},"N/A"),(0,i.kt)("td",{parentName:"tr",align:null},"N/A"),(0,i.kt)("td",{parentName:"tr",align:null},"N/A"),(0,i.kt)("td",{parentName:"tr",align:null},"N/A")))),(0,i.kt)("hr",null),(0,i.kt)("h1",{id:"summary"},"Summary"),(0,i.kt)("p",null,"After an extensive evaluation of six zkVM candidates for the Nescience project, RISC0 emerged as the top choice.\nIt excels in both proof generation time and size while maintaining a reasonable memory footprint. With strong zero-knowledge\nproof capabilities and support for multiple programming languages, it aligns well with our project's needs for privacy,\nperformance, and flexibility. Its overall balance between performance and efficiency makes it the most viable zkVM at this stage."),(0,i.kt)("p",null,"Valida, while promising with its potential for high prover performance, is still in early development and suffers from Rust integration issues.\nThe current LLVM IR transpilation limitations mean it cannot handle complex memory interactions, disqualifying it for now.\nHowever, once its development matures, Valida could become a strong alternative, and we plan to revisit it as it evolves."),(0,i.kt)("p",null,"SP1, though initially interesting, failed to meet the zero-knowledge proof requirement. Its performance in arithmetic operations was\nrespectable but insufficient to justify further consideration given its lack of ZK functionality \u2013 critical for our privacy-first objectives."),(0,i.kt)("p",null,"Nexus demonstrated consistent proof sizes and manageable memory usage, but its lackluster performance during memory-intensive tasks and\nits proof size (especially for larger workloads) disqualified it from being a top contender. While zkMIPS delivered solid proof times,\nthe memory issues were too significant to ignore, making it unsuitable."),(0,i.kt)("p",null,"Finally, zkWASM exhibited the poorest results, struggling both in proof size and generation time. Despite its potential for WASM bytecode support,\nthe excessive RAM consumption (up to 57 GB in the memory test) rendered it impractical for Nescience\u2019s use case."),(0,i.kt)("p",null,"In conclusion, RISC0 is the best fit for Nescience at this stage, but Valida remains a future candidate as its development progresses."),(0,i.kt)("p",null,"In the future, we plan to compare RISC0 and SP1 with CUDA acceleration. Ideally, by that time, more zkVMs will include similar acceleration capabilities,\nenabling a fairer and more comprehensive comparison across platforms."),(0,i.kt)("p",null,"We\u2019d love to hear your thoughts on our zkVM testing process and results! Do you agree with our conclusions, or do you think we missed a promising zkVM?\nWe\u2019re always open to feedback, insights, and suggestions from the community. "),(0,i.kt)("p",null,"Join the discussion and share your perspectives on\n",(0,i.kt)("a",{parentName:"p",href:"https://forum.vac.dev/t/zkvm-testing-report-evaluating-zero-knowledge-virtual-machines-for-nescience/"},"our forum")," or try out the\ntests yourself through our ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vacp2p/nescience-zkvm-testing"},"GitHub page"),"!"),(0,i.kt)("h1",{id:"references"},"References"),(0,i.kt)("p",null,"[1]"," Exploring zkVMs: Which Projects Truly Qualify as Zero-Knowledge Virtual Machines? Retrieved from ",(0,i.kt)("a",{parentName:"p",href:"https://vac.dev/rlog/zkVM-explorations/"},"https://vac.dev/rlog/zkVM-explorations/")),(0,i.kt)("p",null,"[2]"," Nescience: A User-Centric State-Separation Architecture. Retrieved from ",(0,i.kt)("a",{parentName:"p",href:"https://vac.dev/rlog/Nescience-state-separation-architecture"},"https://vac.dev/rlog/Nescience-state-separation-architecture")),(0,i.kt)("p",null,"[3]"," Our GitHub Page for zkVM Testing. Retrieved from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vacp2p/nescience-zkvm-testing"},"https://github.com/vacp2p/nescience-zkvm-testing")),(0,i.kt)("p",null,"[4]"," Introducing SP1: A performant, 100% open-source, contributor-friendly zkVM. Retrieved from ",(0,i.kt)("a",{parentName:"p",href:"https://blog.succinct.xyz/introducing-sp1/"},"https://blog.succinct.xyz/introducing-sp1/")),(0,i.kt)("p",null,"[5]"," The first general purpose zkVM. Retrieved from ",(0,i.kt)("a",{parentName:"p",href:"https://www.risczero.com/zkvm"},"https://www.risczero.com/zkvm")),(0,i.kt)("p",null,"[6]"," The Nexus 2.0 zkVM. Retrieved from ",(0,i.kt)("a",{parentName:"p",href:"https://docs.nexus.xyz/"},"https://docs.nexus.xyz/")),(0,i.kt)("p",null,"[7]"," ZKM Architecture. Retrieved from ",(0,i.kt)("a",{parentName:"p",href:"https://docs.zkm.io/zkm-architecture"},"https://docs.zkm.io/zkm-architecture")),(0,i.kt)("p",null,"[8]"," ZK-WASM. Retrieved from ",(0,i.kt)("a",{parentName:"p",href:"https://delphinuslab.com/zk-wasm/"},"https://delphinuslab.com/zk-wasm/")),(0,i.kt)("p",null,"[9]"," Valida zkVM Design. Retrieved from ",(0,i.kt)("a",{parentName:"p",href:"https://delendum.xyz/writings/2023-05-10-zkvm-design.html"},"https://delendum.xyz/writings/2023-05-10-zkvm-design.html")))}c.isMDXComponent=!0},3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>u});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(a),u=i,g=d["".concat(o,".").concat(u)]||d[u]||c[u]||r;return a?n.createElement(g,l(l({ref:t},m),{},{components:a})):n.createElement(g,l({ref:t},m))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var p=2;p<r;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},93795:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/alloc11-5e8896fbfcf04b3abe1b53fd63b4a04d.png"},64082:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/alloc12-f0d03e2eb102436dd8d14827ffeee782.png"},59108:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/alloc21-f0c07620d2c2a6dcc1cb8dd53d8bf33e.png"},38538:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/alloc22-0f0788c13a8f29a95543b44ffc3f7e5c.png"},80370:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/alloc31-b33243d1b3e859704fa649c3cca423ae.png"},61544:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/alloc32-b4511228d11e730b80e97dbfe14f1b32.png"},85554:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/alloc41-7df1382edc6f2440f4becb9306679308.png"},74498:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/alloc42-29736c27a94ac18072ccad4ba523374d.png"},68593:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/alloc51-987d88b8264639cb4c1edf757b48b8f4.png"},34403:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/alloc52-ebf1d882e709a00714dce2fd122428eb.png"},38337:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/consumed11-9cb04fe0b2e8a8a6e24ae048041099d4.png"},423:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/consumed12-afda980a23ad27bab9dfb32a95a97a3f.png"},17410:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/consumed21-c4091416c0c2cbd0effc9d0e349308ec.png"},26210:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/consumed22-f8b42af736f124afd52887d14e5df7d9.png"},87538:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/consumed31-d75cf19d4acef0f2cafe8eb19a3605c4.png"},20297:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/consumed32-44dfd430560af8658b94a3ef9f7e6e6f.png"},8839:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/consumed41-362c4850d936a407e75ccd58283d88d1.png"},72683:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/consumed42-a28992ae3211a5afb2458cf153e160be.png"},49155:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/consumed51-75711af15f7936d72c04975e332935a7.png"},4229:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/consumed52-51cbe29ddaf2bed5d9fc9018b549a00c.png"},89203:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/general11-51932659ec4e58ad9f1b20013b3abdda.png"},81581:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/general12-aa03eb35a9936b02b34ff2ae3dc2a764.png"},1459:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/general21-06d52d151e217cbc9ebe65b1dee0fd76.png"},84606:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/general22-4c59fa28bca8c2b2cbd3d5f787e48489.png"},25693:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/general31-127358c1aa2715173141d55c78c79d70.png"},4327:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/general32-eb289f0be9cc090fc455d823c26bd310.png"},42204:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/general41-949405deaef610fd9742055a23363f7e.png"},62942:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/general42-39f202b1dfdcecc289d3582e20cde498.png"},81969:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/general51-72f8449fb89dfdd31ab4eeef2bfa8ebf.png"},92076:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/general52-3903edbdaf25478fbcabf8ec390ac257.png"},48805:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sizes11-6ed8118385ec2b2570e7aaeee1f6541e.png"},24860:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sizes12-a05d9e5b04bc487f75d5ec3322619645.png"},85209:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sizes21-b404c76c47b45312f15afe077e97c5d8.png"},76245:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sizes22-e801d2de7a6ae71ed02556af421d17b4.png"},3240:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sizes31-9af6876cd32a8486431c0859f5c15e7c.png"},83519:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sizes32-3011b5545d0899d6c3bf6a3c7f0c1304.png"},64125:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sizes41-2eca56b296b460aa98b34ff0e3642a67.png"},13077:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sizes42-5024bdc66d052e6b6636040cef38bd93.png"},19895:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sizes51-129c42f705ff833ed745045e7803cb6f.png"},72106:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/sizes52-505ad4d2e61ad6462a0e9d100fcf234b.png"},11611:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tempalloc11-2ba6018b7760dfd150567d789283ffdf.png"},90460:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tempalloc12-1e7c0754f86c80cf83b4d58183816de6.png"},64450:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tempalloc21-875ab00f360822c237156c64609b1367.png"},80247:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tempalloc22-214f62229a8d204d44e83dfcf6a69c19.png"},29530:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tempalloc31-7b52143b8f6199186fb0ae7c66486365.png"},61258:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tempalloc32-0a2c79a5578806df5da0f97b15eb1c56.png"},85465:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tempalloc41-3174820f91664038d6fdd966f07bd90d.png"},1484:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tempalloc42-6122a1bdf8c5db3a03fa4249ebb52e1f.png"},73312:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tempalloc51-5b0868395d26e76dac7744b216e4949f.png"},54443:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tempalloc52-ceccc6d4166dbdedebcdb4370acb9650.png"}}]);